

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Packages/com.careboo.blinq/CareBoo.Blinq/ValueSequence/ValueSequence.Sum.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Unity.Collections;
using static ValueFuncs;
using static Utils;
using System.Collections;
using NUnit.Framework;
using Linq = System.Linq.Enumerable;
using Blinq = CareBoo.Blinq.Sequence;

internal class SumTest
{

    internal class Values_int
    {
        public static IEnumerable Values
        {
            get
            {
                yield return new int[0];
                yield return new int[1];
                yield return Linq.ToArray(Linq.Repeat((int)5, 7));
            }
        }
    }

    [Test, Parallelizable]
    public void BlinqShouldEqualLinqNativeArraySum_int(
        [ValueSource(typeof(Values_int), nameof(Values_int.Values))] int[] sourceArr
        )
    {
        var srcNativeArray = new NativeArray<int>(sourceArr, Allocator.Persistent);
        var expected = ExceptionAndValue(() => Linq.Sum(srcNativeArray));
        var actual = ExceptionAndValue(() => Blinq.Sum(srcNativeArray));
        srcNativeArray.Dispose();
    }

    [Test, Parallelizable]
    public void BlinqShouldEqualLinqNativeArraySumSelector_int(
        [ValueSource(typeof(Values_int), nameof(Values_int.Values))] int[] sourceArr
        )
    {
        var srcNativeArray = new NativeArray<int>(sourceArr, Allocator.Persistent);
        var expected = ExceptionAndValue(() => Linq.Sum(srcNativeArray, SelectSelf<int>().Invoke));
        var actual = ExceptionAndValue(() => Blinq.Sum(srcNativeArray, SelectSelf<int>()));
        srcNativeArray.Dispose();
    }


    internal class Values_float
    {
        public static IEnumerable Values
        {
            get
            {
                yield return new float[0];
                yield return new float[1];
                yield return Linq.ToArray(Linq.Repeat((float)5, 7));
            }
        }
    }

    [Test, Parallelizable]
    public void BlinqShouldEqualLinqNativeArraySum_float(
        [ValueSource(typeof(Values_float), nameof(Values_float.Values))] float[] sourceArr
        )
    {
        var srcNativeArray = new NativeArray<float>(sourceArr, Allocator.Persistent);
        var expected = ExceptionAndValue(() => Linq.Sum(srcNativeArray));
        var actual = ExceptionAndValue(() => Blinq.Sum(srcNativeArray));
        srcNativeArray.Dispose();
    }

    [Test, Parallelizable]
    public void BlinqShouldEqualLinqNativeArraySumSelector_float(
        [ValueSource(typeof(Values_float), nameof(Values_float.Values))] float[] sourceArr
        )
    {
        var srcNativeArray = new NativeArray<float>(sourceArr, Allocator.Persistent);
        var expected = ExceptionAndValue(() => Linq.Sum(srcNativeArray, SelectSelf<float>().Invoke));
        var actual = ExceptionAndValue(() => Blinq.Sum(srcNativeArray, SelectSelf<float>()));
        srcNativeArray.Dispose();
    }


    internal class Values_double
    {
        public static IEnumerable Values
        {
            get
            {
                yield return new double[0];
                yield return new double[1];
                yield return Linq.ToArray(Linq.Repeat((double)5, 7));
            }
        }
    }

    [Test, Parallelizable]
    public void BlinqShouldEqualLinqNativeArraySum_double(
        [ValueSource(typeof(Values_double), nameof(Values_double.Values))] double[] sourceArr
        )
    {
        var srcNativeArray = new NativeArray<double>(sourceArr, Allocator.Persistent);
        var expected = ExceptionAndValue(() => Linq.Sum(srcNativeArray));
        var actual = ExceptionAndValue(() => Blinq.Sum(srcNativeArray));
        srcNativeArray.Dispose();
    }

    [Test, Parallelizable]
    public void BlinqShouldEqualLinqNativeArraySumSelector_double(
        [ValueSource(typeof(Values_double), nameof(Values_double.Values))] double[] sourceArr
        )
    {
        var srcNativeArray = new NativeArray<double>(sourceArr, Allocator.Persistent);
        var expected = ExceptionAndValue(() => Linq.Sum(srcNativeArray, SelectSelf<double>().Invoke));
        var actual = ExceptionAndValue(() => Blinq.Sum(srcNativeArray, SelectSelf<double>()));
        srcNativeArray.Dispose();
    }


}
