


//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using CareBoo.Burst.Delegates;
using Unity.Collections;
using Unity.Jobs;
using System.Collections.Generic;

namespace CareBoo.Blinq
{
    public static partial class Sequence
    {

        public static int Max<TSource, TSourceEnumerator>(
            this in ValueSequence<int, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<int, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<int>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var max = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = srcList[i];
                if (val > max)
                    max = val;
            }
            srcList.Dispose();
            return max;
        }

        public struct SequenceMaxFunc_int<TSource, TSourceEnumerator>
            : IFunc<ValueSequence<int, TSource, TSourceEnumerator>, int>
            where TSource : struct, ISequence<int, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<int>
        {
            public int Invoke(ValueSequence<int, TSource, TSourceEnumerator> seq)
            {
                return seq.Max();
            }
        }

        public static ValueFunc<ValueSequence<int, TSource, TSourceEnumerator>, int>.Struct<SequenceMaxFunc_int<TSource, TSourceEnumerator>>
        MaxAsFunc<TSource, TSourceEnumerator>(
            this in ValueSequence<int, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<int, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<int>
        {
            return ValueFunc<ValueSequence<int, TSource, TSourceEnumerator>, int>.New<SequenceMaxFunc_int<TSource, TSourceEnumerator>>();
        }

        public static int RunMax<TSource, TSourceEnumerator>(
            this in ValueSequence<int, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<int, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<int>
        {
            var func = source.MaxAsFunc();
            return source.Run(func);
        }

        public static JobHandle<int> ScheduleMax<TSource, TSourceEnumerator>(
            this in ValueSequence<int, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<int, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<int>
        {
            var func = source.MaxAsFunc();
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMax<TSource, TSourceEnumerator>(
            this in ValueSequence<int, TSource, TSourceEnumerator> source,
            ref NativeArray<int> output
            )
            where TSource : struct, ISequence<int, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<int>
        {
            var func = source.MaxAsFunc();
            return source.Schedule(func, ref output);
        }

        public static int Min<TSource, TSourceEnumerator>(
            this in ValueSequence<int, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<int, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<int>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var min = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = srcList[i];
                if (val < min)
                    min = val;
            }
            srcList.Dispose();
            return min;
        }

        public struct SequenceMinFunc_int<TSource, TSourceEnumerator>
            : IFunc<ValueSequence<int, TSource, TSourceEnumerator>, int>
            where TSource : struct, ISequence<int, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<int>
        {
            public int Invoke(ValueSequence<int, TSource, TSourceEnumerator> seq)
            {
                return seq.Min();
            }
        }

        public static ValueFunc<ValueSequence<int, TSource, TSourceEnumerator>, int>.Struct<SequenceMinFunc_int<TSource, TSourceEnumerator>>
        MinAsFunc<TSource, TSourceEnumerator>(
            this in ValueSequence<int, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<int, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<int>
        {
            return ValueFunc<ValueSequence<int, TSource, TSourceEnumerator>, int>.New<SequenceMinFunc_int<TSource, TSourceEnumerator>>();
        }

        public static int RunMin<TSource, TSourceEnumerator>(
            this in ValueSequence<int, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<int, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<int>
        {
            var func = source.MinAsFunc();
            return source.Run(func);
        }

        public static JobHandle<int> ScheduleMin<TSource, TSourceEnumerator>(
            this in ValueSequence<int, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<int, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<int>
        {
            var func = source.MinAsFunc();
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMin<TSource, TSourceEnumerator>(
            this in ValueSequence<int, TSource, TSourceEnumerator> source,
            ref NativeArray<int> output
            )
            where TSource : struct, ISequence<int, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<int>
        {
            var func = source.MinAsFunc();
            return source.Schedule(func, ref output);
        }

        public static int Max<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, int>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var max = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = selector.Invoke(srcList[i]);
                if (val > max)
                    max = val;
            }
            srcList.Dispose();
            return max;
        }

        public struct SequenceMaxFunc_int<T, TSource, TSourceEnumerator, TSelector>
            : IFunc<ValueSequence<T, TSource, TSourceEnumerator>, int>
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, int>
        {
            public ValueFunc<T, int>.Struct<TSelector> Selector;

            public int Invoke(ValueSequence<T, TSource, TSourceEnumerator> seq)
            {
                return seq.Max(Selector);
            }
        }

        public static ValueFunc<ValueSequence<T, TSource, TSourceEnumerator>, int>.Struct<SequenceMaxFunc_int<T, TSource, TSourceEnumerator, TSelector>>
        MaxAsFunc<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, int>
        {
            var func = new SequenceMaxFunc_int<T, TSource, TSourceEnumerator, TSelector> { Selector = selector };
            return ValueFunc<ValueSequence<T, TSource, TSourceEnumerator>, int>.New(func);
        }

        public static int RunMax<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, int>
        {
            var func = source.MaxAsFunc(selector);
            return source.Run(func);
        }

        public static JobHandle<int> ScheduleMax<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, int>
        {
            var func = source.MaxAsFunc(selector);
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMax<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ref NativeArray<int> output,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, int>
        {
            var func = source.MaxAsFunc(selector);
            return source.Schedule(func, ref output);
        }

        public static int Min<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, int>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var min = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = selector.Invoke(srcList[i]);
                if (val < min)
                    min = val;
            }
            srcList.Dispose();
            return min;
        }

        public struct SequenceMinFunc_int<T, TSource, TSourceEnumerator, TSelector>
            : IFunc<ValueSequence<T, TSource, TSourceEnumerator>, int>
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, int>
        {
            public ValueFunc<T, int>.Struct<TSelector> Selector;

            public int Invoke(ValueSequence<T, TSource, TSourceEnumerator> seq)
            {
                return seq.Min(Selector);
            }
        }

        public static ValueFunc<ValueSequence<T, TSource, TSourceEnumerator>, int>.Struct<SequenceMinFunc_int<T, TSource, TSourceEnumerator, TSelector>>
        MinAsFunc<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, int>
        {
            var func = new SequenceMinFunc_int<T, TSource, TSourceEnumerator, TSelector> { Selector = selector };
            return ValueFunc<ValueSequence<T, TSource, TSourceEnumerator>, int>.New(func);
        }

        public static int RunMin<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, int>
        {
            var func = source.MinAsFunc(selector);
            return source.Run(func);
        }

        public static JobHandle<int> ScheduleMin<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, int>
        {
            var func = source.MinAsFunc(selector);
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMin<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ref NativeArray<int> output,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, int>
        {
            var func = source.MinAsFunc(selector);
            return source.Schedule(func, ref output);
        }


        public static uint Max<TSource, TSourceEnumerator>(
            this in ValueSequence<uint, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<uint, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<uint>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var max = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = srcList[i];
                if (val > max)
                    max = val;
            }
            srcList.Dispose();
            return max;
        }

        public struct SequenceMaxFunc_uint<TSource, TSourceEnumerator>
            : IFunc<ValueSequence<uint, TSource, TSourceEnumerator>, uint>
            where TSource : struct, ISequence<uint, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<uint>
        {
            public uint Invoke(ValueSequence<uint, TSource, TSourceEnumerator> seq)
            {
                return seq.Max();
            }
        }

        public static ValueFunc<ValueSequence<uint, TSource, TSourceEnumerator>, uint>.Struct<SequenceMaxFunc_uint<TSource, TSourceEnumerator>>
        MaxAsFunc<TSource, TSourceEnumerator>(
            this in ValueSequence<uint, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<uint, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<uint>
        {
            return ValueFunc<ValueSequence<uint, TSource, TSourceEnumerator>, uint>.New<SequenceMaxFunc_uint<TSource, TSourceEnumerator>>();
        }

        public static uint RunMax<TSource, TSourceEnumerator>(
            this in ValueSequence<uint, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<uint, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<uint>
        {
            var func = source.MaxAsFunc();
            return source.Run(func);
        }

        public static JobHandle<uint> ScheduleMax<TSource, TSourceEnumerator>(
            this in ValueSequence<uint, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<uint, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<uint>
        {
            var func = source.MaxAsFunc();
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMax<TSource, TSourceEnumerator>(
            this in ValueSequence<uint, TSource, TSourceEnumerator> source,
            ref NativeArray<uint> output
            )
            where TSource : struct, ISequence<uint, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<uint>
        {
            var func = source.MaxAsFunc();
            return source.Schedule(func, ref output);
        }

        public static uint Min<TSource, TSourceEnumerator>(
            this in ValueSequence<uint, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<uint, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<uint>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var min = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = srcList[i];
                if (val < min)
                    min = val;
            }
            srcList.Dispose();
            return min;
        }

        public struct SequenceMinFunc_uint<TSource, TSourceEnumerator>
            : IFunc<ValueSequence<uint, TSource, TSourceEnumerator>, uint>
            where TSource : struct, ISequence<uint, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<uint>
        {
            public uint Invoke(ValueSequence<uint, TSource, TSourceEnumerator> seq)
            {
                return seq.Min();
            }
        }

        public static ValueFunc<ValueSequence<uint, TSource, TSourceEnumerator>, uint>.Struct<SequenceMinFunc_uint<TSource, TSourceEnumerator>>
        MinAsFunc<TSource, TSourceEnumerator>(
            this in ValueSequence<uint, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<uint, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<uint>
        {
            return ValueFunc<ValueSequence<uint, TSource, TSourceEnumerator>, uint>.New<SequenceMinFunc_uint<TSource, TSourceEnumerator>>();
        }

        public static uint RunMin<TSource, TSourceEnumerator>(
            this in ValueSequence<uint, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<uint, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<uint>
        {
            var func = source.MinAsFunc();
            return source.Run(func);
        }

        public static JobHandle<uint> ScheduleMin<TSource, TSourceEnumerator>(
            this in ValueSequence<uint, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<uint, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<uint>
        {
            var func = source.MinAsFunc();
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMin<TSource, TSourceEnumerator>(
            this in ValueSequence<uint, TSource, TSourceEnumerator> source,
            ref NativeArray<uint> output
            )
            where TSource : struct, ISequence<uint, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<uint>
        {
            var func = source.MinAsFunc();
            return source.Schedule(func, ref output);
        }

        public static uint Max<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, uint>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var max = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = selector.Invoke(srcList[i]);
                if (val > max)
                    max = val;
            }
            srcList.Dispose();
            return max;
        }

        public struct SequenceMaxFunc_uint<T, TSource, TSourceEnumerator, TSelector>
            : IFunc<ValueSequence<T, TSource, TSourceEnumerator>, uint>
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, uint>
        {
            public ValueFunc<T, uint>.Struct<TSelector> Selector;

            public uint Invoke(ValueSequence<T, TSource, TSourceEnumerator> seq)
            {
                return seq.Max(Selector);
            }
        }

        public static ValueFunc<ValueSequence<T, TSource, TSourceEnumerator>, uint>.Struct<SequenceMaxFunc_uint<T, TSource, TSourceEnumerator, TSelector>>
        MaxAsFunc<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, uint>
        {
            var func = new SequenceMaxFunc_uint<T, TSource, TSourceEnumerator, TSelector> { Selector = selector };
            return ValueFunc<ValueSequence<T, TSource, TSourceEnumerator>, uint>.New(func);
        }

        public static uint RunMax<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, uint>
        {
            var func = source.MaxAsFunc(selector);
            return source.Run(func);
        }

        public static JobHandle<uint> ScheduleMax<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, uint>
        {
            var func = source.MaxAsFunc(selector);
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMax<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ref NativeArray<uint> output,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, uint>
        {
            var func = source.MaxAsFunc(selector);
            return source.Schedule(func, ref output);
        }

        public static uint Min<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, uint>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var min = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = selector.Invoke(srcList[i]);
                if (val < min)
                    min = val;
            }
            srcList.Dispose();
            return min;
        }

        public struct SequenceMinFunc_uint<T, TSource, TSourceEnumerator, TSelector>
            : IFunc<ValueSequence<T, TSource, TSourceEnumerator>, uint>
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, uint>
        {
            public ValueFunc<T, uint>.Struct<TSelector> Selector;

            public uint Invoke(ValueSequence<T, TSource, TSourceEnumerator> seq)
            {
                return seq.Min(Selector);
            }
        }

        public static ValueFunc<ValueSequence<T, TSource, TSourceEnumerator>, uint>.Struct<SequenceMinFunc_uint<T, TSource, TSourceEnumerator, TSelector>>
        MinAsFunc<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, uint>
        {
            var func = new SequenceMinFunc_uint<T, TSource, TSourceEnumerator, TSelector> { Selector = selector };
            return ValueFunc<ValueSequence<T, TSource, TSourceEnumerator>, uint>.New(func);
        }

        public static uint RunMin<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, uint>
        {
            var func = source.MinAsFunc(selector);
            return source.Run(func);
        }

        public static JobHandle<uint> ScheduleMin<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, uint>
        {
            var func = source.MinAsFunc(selector);
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMin<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ref NativeArray<uint> output,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, uint>
        {
            var func = source.MinAsFunc(selector);
            return source.Schedule(func, ref output);
        }


        public static float Max<TSource, TSourceEnumerator>(
            this in ValueSequence<float, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<float, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<float>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var max = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = srcList[i];
                if (val > max)
                    max = val;
            }
            srcList.Dispose();
            return max;
        }

        public struct SequenceMaxFunc_float<TSource, TSourceEnumerator>
            : IFunc<ValueSequence<float, TSource, TSourceEnumerator>, float>
            where TSource : struct, ISequence<float, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<float>
        {
            public float Invoke(ValueSequence<float, TSource, TSourceEnumerator> seq)
            {
                return seq.Max();
            }
        }

        public static ValueFunc<ValueSequence<float, TSource, TSourceEnumerator>, float>.Struct<SequenceMaxFunc_float<TSource, TSourceEnumerator>>
        MaxAsFunc<TSource, TSourceEnumerator>(
            this in ValueSequence<float, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<float, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<float>
        {
            return ValueFunc<ValueSequence<float, TSource, TSourceEnumerator>, float>.New<SequenceMaxFunc_float<TSource, TSourceEnumerator>>();
        }

        public static float RunMax<TSource, TSourceEnumerator>(
            this in ValueSequence<float, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<float, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<float>
        {
            var func = source.MaxAsFunc();
            return source.Run(func);
        }

        public static JobHandle<float> ScheduleMax<TSource, TSourceEnumerator>(
            this in ValueSequence<float, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<float, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<float>
        {
            var func = source.MaxAsFunc();
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMax<TSource, TSourceEnumerator>(
            this in ValueSequence<float, TSource, TSourceEnumerator> source,
            ref NativeArray<float> output
            )
            where TSource : struct, ISequence<float, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<float>
        {
            var func = source.MaxAsFunc();
            return source.Schedule(func, ref output);
        }

        public static float Min<TSource, TSourceEnumerator>(
            this in ValueSequence<float, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<float, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<float>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var min = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = srcList[i];
                if (val < min)
                    min = val;
            }
            srcList.Dispose();
            return min;
        }

        public struct SequenceMinFunc_float<TSource, TSourceEnumerator>
            : IFunc<ValueSequence<float, TSource, TSourceEnumerator>, float>
            where TSource : struct, ISequence<float, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<float>
        {
            public float Invoke(ValueSequence<float, TSource, TSourceEnumerator> seq)
            {
                return seq.Min();
            }
        }

        public static ValueFunc<ValueSequence<float, TSource, TSourceEnumerator>, float>.Struct<SequenceMinFunc_float<TSource, TSourceEnumerator>>
        MinAsFunc<TSource, TSourceEnumerator>(
            this in ValueSequence<float, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<float, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<float>
        {
            return ValueFunc<ValueSequence<float, TSource, TSourceEnumerator>, float>.New<SequenceMinFunc_float<TSource, TSourceEnumerator>>();
        }

        public static float RunMin<TSource, TSourceEnumerator>(
            this in ValueSequence<float, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<float, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<float>
        {
            var func = source.MinAsFunc();
            return source.Run(func);
        }

        public static JobHandle<float> ScheduleMin<TSource, TSourceEnumerator>(
            this in ValueSequence<float, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<float, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<float>
        {
            var func = source.MinAsFunc();
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMin<TSource, TSourceEnumerator>(
            this in ValueSequence<float, TSource, TSourceEnumerator> source,
            ref NativeArray<float> output
            )
            where TSource : struct, ISequence<float, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<float>
        {
            var func = source.MinAsFunc();
            return source.Schedule(func, ref output);
        }

        public static float Max<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, float>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var max = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = selector.Invoke(srcList[i]);
                if (val > max)
                    max = val;
            }
            srcList.Dispose();
            return max;
        }

        public struct SequenceMaxFunc_float<T, TSource, TSourceEnumerator, TSelector>
            : IFunc<ValueSequence<T, TSource, TSourceEnumerator>, float>
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, float>
        {
            public ValueFunc<T, float>.Struct<TSelector> Selector;

            public float Invoke(ValueSequence<T, TSource, TSourceEnumerator> seq)
            {
                return seq.Max(Selector);
            }
        }

        public static ValueFunc<ValueSequence<T, TSource, TSourceEnumerator>, float>.Struct<SequenceMaxFunc_float<T, TSource, TSourceEnumerator, TSelector>>
        MaxAsFunc<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, float>
        {
            var func = new SequenceMaxFunc_float<T, TSource, TSourceEnumerator, TSelector> { Selector = selector };
            return ValueFunc<ValueSequence<T, TSource, TSourceEnumerator>, float>.New(func);
        }

        public static float RunMax<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, float>
        {
            var func = source.MaxAsFunc(selector);
            return source.Run(func);
        }

        public static JobHandle<float> ScheduleMax<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, float>
        {
            var func = source.MaxAsFunc(selector);
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMax<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ref NativeArray<float> output,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, float>
        {
            var func = source.MaxAsFunc(selector);
            return source.Schedule(func, ref output);
        }

        public static float Min<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, float>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var min = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = selector.Invoke(srcList[i]);
                if (val < min)
                    min = val;
            }
            srcList.Dispose();
            return min;
        }

        public struct SequenceMinFunc_float<T, TSource, TSourceEnumerator, TSelector>
            : IFunc<ValueSequence<T, TSource, TSourceEnumerator>, float>
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, float>
        {
            public ValueFunc<T, float>.Struct<TSelector> Selector;

            public float Invoke(ValueSequence<T, TSource, TSourceEnumerator> seq)
            {
                return seq.Min(Selector);
            }
        }

        public static ValueFunc<ValueSequence<T, TSource, TSourceEnumerator>, float>.Struct<SequenceMinFunc_float<T, TSource, TSourceEnumerator, TSelector>>
        MinAsFunc<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, float>
        {
            var func = new SequenceMinFunc_float<T, TSource, TSourceEnumerator, TSelector> { Selector = selector };
            return ValueFunc<ValueSequence<T, TSource, TSourceEnumerator>, float>.New(func);
        }

        public static float RunMin<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, float>
        {
            var func = source.MinAsFunc(selector);
            return source.Run(func);
        }

        public static JobHandle<float> ScheduleMin<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, float>
        {
            var func = source.MinAsFunc(selector);
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMin<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ref NativeArray<float> output,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, float>
        {
            var func = source.MinAsFunc(selector);
            return source.Schedule(func, ref output);
        }


        public static double Max<TSource, TSourceEnumerator>(
            this in ValueSequence<double, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<double, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<double>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var max = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = srcList[i];
                if (val > max)
                    max = val;
            }
            srcList.Dispose();
            return max;
        }

        public struct SequenceMaxFunc_double<TSource, TSourceEnumerator>
            : IFunc<ValueSequence<double, TSource, TSourceEnumerator>, double>
            where TSource : struct, ISequence<double, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<double>
        {
            public double Invoke(ValueSequence<double, TSource, TSourceEnumerator> seq)
            {
                return seq.Max();
            }
        }

        public static ValueFunc<ValueSequence<double, TSource, TSourceEnumerator>, double>.Struct<SequenceMaxFunc_double<TSource, TSourceEnumerator>>
        MaxAsFunc<TSource, TSourceEnumerator>(
            this in ValueSequence<double, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<double, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<double>
        {
            return ValueFunc<ValueSequence<double, TSource, TSourceEnumerator>, double>.New<SequenceMaxFunc_double<TSource, TSourceEnumerator>>();
        }

        public static double RunMax<TSource, TSourceEnumerator>(
            this in ValueSequence<double, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<double, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<double>
        {
            var func = source.MaxAsFunc();
            return source.Run(func);
        }

        public static JobHandle<double> ScheduleMax<TSource, TSourceEnumerator>(
            this in ValueSequence<double, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<double, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<double>
        {
            var func = source.MaxAsFunc();
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMax<TSource, TSourceEnumerator>(
            this in ValueSequence<double, TSource, TSourceEnumerator> source,
            ref NativeArray<double> output
            )
            where TSource : struct, ISequence<double, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<double>
        {
            var func = source.MaxAsFunc();
            return source.Schedule(func, ref output);
        }

        public static double Min<TSource, TSourceEnumerator>(
            this in ValueSequence<double, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<double, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<double>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var min = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = srcList[i];
                if (val < min)
                    min = val;
            }
            srcList.Dispose();
            return min;
        }

        public struct SequenceMinFunc_double<TSource, TSourceEnumerator>
            : IFunc<ValueSequence<double, TSource, TSourceEnumerator>, double>
            where TSource : struct, ISequence<double, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<double>
        {
            public double Invoke(ValueSequence<double, TSource, TSourceEnumerator> seq)
            {
                return seq.Min();
            }
        }

        public static ValueFunc<ValueSequence<double, TSource, TSourceEnumerator>, double>.Struct<SequenceMinFunc_double<TSource, TSourceEnumerator>>
        MinAsFunc<TSource, TSourceEnumerator>(
            this in ValueSequence<double, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<double, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<double>
        {
            return ValueFunc<ValueSequence<double, TSource, TSourceEnumerator>, double>.New<SequenceMinFunc_double<TSource, TSourceEnumerator>>();
        }

        public static double RunMin<TSource, TSourceEnumerator>(
            this in ValueSequence<double, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<double, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<double>
        {
            var func = source.MinAsFunc();
            return source.Run(func);
        }

        public static JobHandle<double> ScheduleMin<TSource, TSourceEnumerator>(
            this in ValueSequence<double, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<double, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<double>
        {
            var func = source.MinAsFunc();
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMin<TSource, TSourceEnumerator>(
            this in ValueSequence<double, TSource, TSourceEnumerator> source,
            ref NativeArray<double> output
            )
            where TSource : struct, ISequence<double, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<double>
        {
            var func = source.MinAsFunc();
            return source.Schedule(func, ref output);
        }

        public static double Max<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, double>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var max = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = selector.Invoke(srcList[i]);
                if (val > max)
                    max = val;
            }
            srcList.Dispose();
            return max;
        }

        public struct SequenceMaxFunc_double<T, TSource, TSourceEnumerator, TSelector>
            : IFunc<ValueSequence<T, TSource, TSourceEnumerator>, double>
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, double>
        {
            public ValueFunc<T, double>.Struct<TSelector> Selector;

            public double Invoke(ValueSequence<T, TSource, TSourceEnumerator> seq)
            {
                return seq.Max(Selector);
            }
        }

        public static ValueFunc<ValueSequence<T, TSource, TSourceEnumerator>, double>.Struct<SequenceMaxFunc_double<T, TSource, TSourceEnumerator, TSelector>>
        MaxAsFunc<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, double>
        {
            var func = new SequenceMaxFunc_double<T, TSource, TSourceEnumerator, TSelector> { Selector = selector };
            return ValueFunc<ValueSequence<T, TSource, TSourceEnumerator>, double>.New(func);
        }

        public static double RunMax<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, double>
        {
            var func = source.MaxAsFunc(selector);
            return source.Run(func);
        }

        public static JobHandle<double> ScheduleMax<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, double>
        {
            var func = source.MaxAsFunc(selector);
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMax<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ref NativeArray<double> output,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, double>
        {
            var func = source.MaxAsFunc(selector);
            return source.Schedule(func, ref output);
        }

        public static double Min<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, double>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var min = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = selector.Invoke(srcList[i]);
                if (val < min)
                    min = val;
            }
            srcList.Dispose();
            return min;
        }

        public struct SequenceMinFunc_double<T, TSource, TSourceEnumerator, TSelector>
            : IFunc<ValueSequence<T, TSource, TSourceEnumerator>, double>
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, double>
        {
            public ValueFunc<T, double>.Struct<TSelector> Selector;

            public double Invoke(ValueSequence<T, TSource, TSourceEnumerator> seq)
            {
                return seq.Min(Selector);
            }
        }

        public static ValueFunc<ValueSequence<T, TSource, TSourceEnumerator>, double>.Struct<SequenceMinFunc_double<T, TSource, TSourceEnumerator, TSelector>>
        MinAsFunc<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, double>
        {
            var func = new SequenceMinFunc_double<T, TSource, TSourceEnumerator, TSelector> { Selector = selector };
            return ValueFunc<ValueSequence<T, TSource, TSourceEnumerator>, double>.New(func);
        }

        public static double RunMin<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, double>
        {
            var func = source.MinAsFunc(selector);
            return source.Run(func);
        }

        public static JobHandle<double> ScheduleMin<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, double>
        {
            var func = source.MinAsFunc(selector);
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMin<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ref NativeArray<double> output,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, double>
        {
            var func = source.MinAsFunc(selector);
            return source.Schedule(func, ref output);
        }


    }
}
