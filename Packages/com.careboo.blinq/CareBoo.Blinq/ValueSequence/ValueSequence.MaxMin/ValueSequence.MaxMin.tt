<#@ assembly name="System.Core" #>
<#@ output extension=".gen.cs" #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using CareBoo.Burst.Delegates;
using Unity.Collections;
using System.Collections.Generic;

namespace CareBoo.Blinq
{
    public static partial class Sequence
    {
<#
var TYPES = new[] { "int", "uint", "float", "double" };
foreach (string TYPE_FULL in TYPES)
{
#>
        public static <#=TYPE_FULL#> Max<TSource, TSourceEnumerator>(
            this in ValueSequence<<#=TYPE_FULL#>, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<<#=TYPE_FULL#>, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<<#=TYPE_FULL#>>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var max = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = srcList[i];
                if (val > max)
                    max = val;
            }
            srcList.Dispose();
            return max;
        }

        public static <#=TYPE_FULL#> Min<TSource, TSourceEnumerator>(
            this in ValueSequence<<#=TYPE_FULL#>, TSource, TSourceEnumerator> source
            )
            where TSource : struct, ISequence<<#=TYPE_FULL#>, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<<#=TYPE_FULL#>>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var min = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = srcList[i];
                if (val < min)
                    min = val;
            }
            srcList.Dispose();
            return min;
        }

        public static <#=TYPE_FULL#> Max<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, <#=TYPE_FULL#>>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, <#=TYPE_FULL#>>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var max = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = selector.Invoke(srcList[i]);
                if (val > max)
                    max = val;
            }
            srcList.Dispose();
            return max;
        }

        public static <#=TYPE_FULL#> Min<T, TSource, TSourceEnumerator, TSelector>(
            this in ValueSequence<T, TSource, TSourceEnumerator> source,
            ValueFunc<T, <#=TYPE_FULL#>>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T, TSourceEnumerator>
            where TSourceEnumerator : struct, IEnumerator<T>
            where TSelector : struct, IFunc<T, <#=TYPE_FULL#>>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }

            var min = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
            {
                var val = selector.Invoke(srcList[i]);
                if (val < min)
                    min = val;
            }
            srcList.Dispose();
            return min;
        }

<#
}
#>
    }
}
