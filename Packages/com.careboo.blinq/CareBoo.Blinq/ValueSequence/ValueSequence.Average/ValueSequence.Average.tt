<#@ assembly name="System.Core" #>
<#@ output extension=".gen.cs" #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Packages/com.careboo.blinq/CareBoo.Blinq/ValueSequence/ValueSequence.Sum.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using CareBoo.Burst.Delegates;

namespace CareBoo.Blinq
{
    public static partial class Sequence
    {
<#
var TYPES = new[] { "int", "uint", "float", "double" };
foreach (string TYPE in TYPES)
{
    for (var i = 1; i<= 4; i++)
    {
        for (var j = 1; j <= 4; j++)
        {
            string NUM1 = i == 1 ? "" : i.ToString();
            if (i == 1 && j > 1) break;
            string SEP = j == 1 ? "" : "x";
            string NUM2 = j == 1 ? "" : j.ToString();
            string TYPE_FULL = $"{TYPE}{NUM1}{SEP}{NUM2}";
            string UINT_CAST = TYPE == "uint" ? "(uint)" : "";
#>
        public struct AverageJobHandle_<#=TYPE_FULL#> : IDisposable
        {
            JobHandle handle;
            NativeArray<<#=TYPE_FULL#>> output;

            public AverageJobHandle_<#=TYPE_FULL#>(ref JobHandle handle, ref NativeArray<<#=TYPE_FULL#>> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public <#=TYPE_FULL#> Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static <#=TYPE_FULL#> Average<TSource>(
            this in ValueSequence<<#=TYPE_FULL#>, TSource> source
            )
            where TSource : struct, ISequence<<#=TYPE_FULL#>>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            <#=TYPE_FULL#> sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / <#=UINT_CAST#>srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_<#=TYPE_FULL#><TSource>
            : IJob
            where TSource : struct, ISequence<<#=TYPE_FULL#>>
        {
            [ReadOnly]
            public ValueSequence<<#=TYPE_FULL#>, TSource> Source;

            [WriteOnly]
            public NativeArray<<#=TYPE_FULL#>> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static <#=TYPE_FULL#> RunAverage<TSource>(
            this in ValueSequence<<#=TYPE_FULL#>, TSource> source
            )
            where TSource : struct, ISequence<<#=TYPE_FULL#>>
        {
            var output = new NativeArray<<#=TYPE_FULL#>>(1, Allocator.Persistent);
            new AverageJob_<#=TYPE_FULL#><TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<<#=TYPE_FULL#>, TSource> source,
            in NativeArray<<#=TYPE_FULL#>> output
            )
            where TSource : struct, ISequence<<#=TYPE_FULL#>>
        {
            return new AverageJob_<#=TYPE_FULL#><TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_<#=TYPE_FULL#> ScheduleAverage<TSource>(
            this in ValueSequence<<#=TYPE_FULL#>, TSource> source
            )
            where TSource : struct, ISequence<<#=TYPE_FULL#>>
        {
            var output = new NativeArray<<#=TYPE_FULL#>>(1, Allocator.Persistent);
            var handle = new AverageJob_<#=TYPE_FULL#><TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_<#=TYPE_FULL#>(ref handle, ref output);
        }

        public static <#=TYPE_FULL#> Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, <#=TYPE_FULL#>>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, <#=TYPE_FULL#>>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            <#=TYPE_FULL#> sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / <#=UINT_CAST#>srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_<#=TYPE_FULL#><T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, <#=TYPE_FULL#>>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, <#=TYPE_FULL#>>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<<#=TYPE_FULL#>> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static <#=TYPE_FULL#> RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, <#=TYPE_FULL#>>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, <#=TYPE_FULL#>>
        {
            var output = new NativeArray<<#=TYPE_FULL#>>(1, Allocator.Persistent);
            new AverageJobSelector_<#=TYPE_FULL#><T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, <#=TYPE_FULL#>>.Struct<TSelector> selector,
            in NativeArray<<#=TYPE_FULL#>> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, <#=TYPE_FULL#>>
        {
            return new AverageJobSelector_<#=TYPE_FULL#><T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_<#=TYPE_FULL#> ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, <#=TYPE_FULL#>>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, <#=TYPE_FULL#>>
        {
            var output = new NativeArray<<#=TYPE_FULL#>>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_<#=TYPE_FULL#><T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_<#=TYPE_FULL#>(ref handle, ref output);
        }

<#
        }
    }
}
#>
    }
}
