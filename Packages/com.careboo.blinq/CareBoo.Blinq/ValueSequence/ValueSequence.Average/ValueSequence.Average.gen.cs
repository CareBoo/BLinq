


//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Packages/com.careboo.blinq/CareBoo.Blinq/ValueSequence/ValueSequence.Sum.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using CareBoo.Burst.Delegates;

namespace CareBoo.Blinq
{
    public static partial class Sequence
    {

        public struct AverageJobHandle_int : IDisposable
        {
            JobHandle handle;
            NativeArray<int> output;

            public AverageJobHandle_int(ref JobHandle handle, ref NativeArray<int> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public int Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static int Average<TSource>(
            this in ValueSequence<int, TSource> source
            )
            where TSource : struct, ISequence<int>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_int<TSource>
            : IJob
            where TSource : struct, ISequence<int>
        {
            [ReadOnly]
            public ValueSequence<int, TSource> Source;

            [WriteOnly]
            public NativeArray<int> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static int RunAverage<TSource>(
            this in ValueSequence<int, TSource> source
            )
            where TSource : struct, ISequence<int>
        {
            var output = new NativeArray<int>(1, Allocator.Persistent);
            new AverageJob_int<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<int, TSource> source,
            in NativeArray<int> output
            )
            where TSource : struct, ISequence<int>
        {
            return new AverageJob_int<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_int ScheduleAverage<TSource>(
            this in ValueSequence<int, TSource> source
            )
            where TSource : struct, ISequence<int>
        {
            var output = new NativeArray<int>(1, Allocator.Persistent);
            var handle = new AverageJob_int<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_int(ref handle, ref output);
        }

        public static int Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_int<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, int>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<int> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static int RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int>
        {
            var output = new NativeArray<int>(1, Allocator.Persistent);
            new AverageJobSelector_int<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int>.Struct<TSelector> selector,
            in NativeArray<int> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int>
        {
            return new AverageJobSelector_int<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_int ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int>
        {
            var output = new NativeArray<int>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_int<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_int(ref handle, ref output);
        }


        public struct AverageJobHandle_int2 : IDisposable
        {
            JobHandle handle;
            NativeArray<int2> output;

            public AverageJobHandle_int2(ref JobHandle handle, ref NativeArray<int2> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public int2 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static int2 Average<TSource>(
            this in ValueSequence<int2, TSource> source
            )
            where TSource : struct, ISequence<int2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int2 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_int2<TSource>
            : IJob
            where TSource : struct, ISequence<int2>
        {
            [ReadOnly]
            public ValueSequence<int2, TSource> Source;

            [WriteOnly]
            public NativeArray<int2> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static int2 RunAverage<TSource>(
            this in ValueSequence<int2, TSource> source
            )
            where TSource : struct, ISequence<int2>
        {
            var output = new NativeArray<int2>(1, Allocator.Persistent);
            new AverageJob_int2<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<int2, TSource> source,
            in NativeArray<int2> output
            )
            where TSource : struct, ISequence<int2>
        {
            return new AverageJob_int2<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_int2 ScheduleAverage<TSource>(
            this in ValueSequence<int2, TSource> source
            )
            where TSource : struct, ISequence<int2>
        {
            var output = new NativeArray<int2>(1, Allocator.Persistent);
            var handle = new AverageJob_int2<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_int2(ref handle, ref output);
        }

        public static int2 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int2 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_int2<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, int2>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<int2> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static int2 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2>
        {
            var output = new NativeArray<int2>(1, Allocator.Persistent);
            new AverageJobSelector_int2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int2>.Struct<TSelector> selector,
            in NativeArray<int2> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2>
        {
            return new AverageJobSelector_int2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_int2 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2>
        {
            var output = new NativeArray<int2>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_int2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_int2(ref handle, ref output);
        }


        public struct AverageJobHandle_int2x2 : IDisposable
        {
            JobHandle handle;
            NativeArray<int2x2> output;

            public AverageJobHandle_int2x2(ref JobHandle handle, ref NativeArray<int2x2> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public int2x2 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static int2x2 Average<TSource>(
            this in ValueSequence<int2x2, TSource> source
            )
            where TSource : struct, ISequence<int2x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int2x2 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_int2x2<TSource>
            : IJob
            where TSource : struct, ISequence<int2x2>
        {
            [ReadOnly]
            public ValueSequence<int2x2, TSource> Source;

            [WriteOnly]
            public NativeArray<int2x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static int2x2 RunAverage<TSource>(
            this in ValueSequence<int2x2, TSource> source
            )
            where TSource : struct, ISequence<int2x2>
        {
            var output = new NativeArray<int2x2>(1, Allocator.Persistent);
            new AverageJob_int2x2<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<int2x2, TSource> source,
            in NativeArray<int2x2> output
            )
            where TSource : struct, ISequence<int2x2>
        {
            return new AverageJob_int2x2<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_int2x2 ScheduleAverage<TSource>(
            this in ValueSequence<int2x2, TSource> source
            )
            where TSource : struct, ISequence<int2x2>
        {
            var output = new NativeArray<int2x2>(1, Allocator.Persistent);
            var handle = new AverageJob_int2x2<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_int2x2(ref handle, ref output);
        }

        public static int2x2 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int2x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int2x2 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_int2x2<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2x2>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, int2x2>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<int2x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static int2x2 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int2x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2x2>
        {
            var output = new NativeArray<int2x2>(1, Allocator.Persistent);
            new AverageJobSelector_int2x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int2x2>.Struct<TSelector> selector,
            in NativeArray<int2x2> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2x2>
        {
            return new AverageJobSelector_int2x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_int2x2 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int2x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2x2>
        {
            var output = new NativeArray<int2x2>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_int2x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_int2x2(ref handle, ref output);
        }


        public struct AverageJobHandle_int2x3 : IDisposable
        {
            JobHandle handle;
            NativeArray<int2x3> output;

            public AverageJobHandle_int2x3(ref JobHandle handle, ref NativeArray<int2x3> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public int2x3 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static int2x3 Average<TSource>(
            this in ValueSequence<int2x3, TSource> source
            )
            where TSource : struct, ISequence<int2x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int2x3 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_int2x3<TSource>
            : IJob
            where TSource : struct, ISequence<int2x3>
        {
            [ReadOnly]
            public ValueSequence<int2x3, TSource> Source;

            [WriteOnly]
            public NativeArray<int2x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static int2x3 RunAverage<TSource>(
            this in ValueSequence<int2x3, TSource> source
            )
            where TSource : struct, ISequence<int2x3>
        {
            var output = new NativeArray<int2x3>(1, Allocator.Persistent);
            new AverageJob_int2x3<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<int2x3, TSource> source,
            in NativeArray<int2x3> output
            )
            where TSource : struct, ISequence<int2x3>
        {
            return new AverageJob_int2x3<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_int2x3 ScheduleAverage<TSource>(
            this in ValueSequence<int2x3, TSource> source
            )
            where TSource : struct, ISequence<int2x3>
        {
            var output = new NativeArray<int2x3>(1, Allocator.Persistent);
            var handle = new AverageJob_int2x3<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_int2x3(ref handle, ref output);
        }

        public static int2x3 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int2x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int2x3 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_int2x3<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2x3>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, int2x3>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<int2x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static int2x3 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int2x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2x3>
        {
            var output = new NativeArray<int2x3>(1, Allocator.Persistent);
            new AverageJobSelector_int2x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int2x3>.Struct<TSelector> selector,
            in NativeArray<int2x3> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2x3>
        {
            return new AverageJobSelector_int2x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_int2x3 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int2x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2x3>
        {
            var output = new NativeArray<int2x3>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_int2x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_int2x3(ref handle, ref output);
        }


        public struct AverageJobHandle_int2x4 : IDisposable
        {
            JobHandle handle;
            NativeArray<int2x4> output;

            public AverageJobHandle_int2x4(ref JobHandle handle, ref NativeArray<int2x4> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public int2x4 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static int2x4 Average<TSource>(
            this in ValueSequence<int2x4, TSource> source
            )
            where TSource : struct, ISequence<int2x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int2x4 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_int2x4<TSource>
            : IJob
            where TSource : struct, ISequence<int2x4>
        {
            [ReadOnly]
            public ValueSequence<int2x4, TSource> Source;

            [WriteOnly]
            public NativeArray<int2x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static int2x4 RunAverage<TSource>(
            this in ValueSequence<int2x4, TSource> source
            )
            where TSource : struct, ISequence<int2x4>
        {
            var output = new NativeArray<int2x4>(1, Allocator.Persistent);
            new AverageJob_int2x4<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<int2x4, TSource> source,
            in NativeArray<int2x4> output
            )
            where TSource : struct, ISequence<int2x4>
        {
            return new AverageJob_int2x4<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_int2x4 ScheduleAverage<TSource>(
            this in ValueSequence<int2x4, TSource> source
            )
            where TSource : struct, ISequence<int2x4>
        {
            var output = new NativeArray<int2x4>(1, Allocator.Persistent);
            var handle = new AverageJob_int2x4<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_int2x4(ref handle, ref output);
        }

        public static int2x4 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int2x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int2x4 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_int2x4<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2x4>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, int2x4>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<int2x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static int2x4 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int2x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2x4>
        {
            var output = new NativeArray<int2x4>(1, Allocator.Persistent);
            new AverageJobSelector_int2x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int2x4>.Struct<TSelector> selector,
            in NativeArray<int2x4> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2x4>
        {
            return new AverageJobSelector_int2x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_int2x4 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int2x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int2x4>
        {
            var output = new NativeArray<int2x4>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_int2x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_int2x4(ref handle, ref output);
        }


        public struct AverageJobHandle_int3 : IDisposable
        {
            JobHandle handle;
            NativeArray<int3> output;

            public AverageJobHandle_int3(ref JobHandle handle, ref NativeArray<int3> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public int3 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static int3 Average<TSource>(
            this in ValueSequence<int3, TSource> source
            )
            where TSource : struct, ISequence<int3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int3 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_int3<TSource>
            : IJob
            where TSource : struct, ISequence<int3>
        {
            [ReadOnly]
            public ValueSequence<int3, TSource> Source;

            [WriteOnly]
            public NativeArray<int3> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static int3 RunAverage<TSource>(
            this in ValueSequence<int3, TSource> source
            )
            where TSource : struct, ISequence<int3>
        {
            var output = new NativeArray<int3>(1, Allocator.Persistent);
            new AverageJob_int3<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<int3, TSource> source,
            in NativeArray<int3> output
            )
            where TSource : struct, ISequence<int3>
        {
            return new AverageJob_int3<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_int3 ScheduleAverage<TSource>(
            this in ValueSequence<int3, TSource> source
            )
            where TSource : struct, ISequence<int3>
        {
            var output = new NativeArray<int3>(1, Allocator.Persistent);
            var handle = new AverageJob_int3<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_int3(ref handle, ref output);
        }

        public static int3 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int3 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_int3<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, int3>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<int3> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static int3 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3>
        {
            var output = new NativeArray<int3>(1, Allocator.Persistent);
            new AverageJobSelector_int3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int3>.Struct<TSelector> selector,
            in NativeArray<int3> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3>
        {
            return new AverageJobSelector_int3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_int3 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3>
        {
            var output = new NativeArray<int3>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_int3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_int3(ref handle, ref output);
        }


        public struct AverageJobHandle_int3x2 : IDisposable
        {
            JobHandle handle;
            NativeArray<int3x2> output;

            public AverageJobHandle_int3x2(ref JobHandle handle, ref NativeArray<int3x2> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public int3x2 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static int3x2 Average<TSource>(
            this in ValueSequence<int3x2, TSource> source
            )
            where TSource : struct, ISequence<int3x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int3x2 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_int3x2<TSource>
            : IJob
            where TSource : struct, ISequence<int3x2>
        {
            [ReadOnly]
            public ValueSequence<int3x2, TSource> Source;

            [WriteOnly]
            public NativeArray<int3x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static int3x2 RunAverage<TSource>(
            this in ValueSequence<int3x2, TSource> source
            )
            where TSource : struct, ISequence<int3x2>
        {
            var output = new NativeArray<int3x2>(1, Allocator.Persistent);
            new AverageJob_int3x2<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<int3x2, TSource> source,
            in NativeArray<int3x2> output
            )
            where TSource : struct, ISequence<int3x2>
        {
            return new AverageJob_int3x2<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_int3x2 ScheduleAverage<TSource>(
            this in ValueSequence<int3x2, TSource> source
            )
            where TSource : struct, ISequence<int3x2>
        {
            var output = new NativeArray<int3x2>(1, Allocator.Persistent);
            var handle = new AverageJob_int3x2<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_int3x2(ref handle, ref output);
        }

        public static int3x2 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int3x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int3x2 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_int3x2<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3x2>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, int3x2>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<int3x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static int3x2 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int3x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3x2>
        {
            var output = new NativeArray<int3x2>(1, Allocator.Persistent);
            new AverageJobSelector_int3x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int3x2>.Struct<TSelector> selector,
            in NativeArray<int3x2> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3x2>
        {
            return new AverageJobSelector_int3x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_int3x2 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int3x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3x2>
        {
            var output = new NativeArray<int3x2>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_int3x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_int3x2(ref handle, ref output);
        }


        public struct AverageJobHandle_int3x3 : IDisposable
        {
            JobHandle handle;
            NativeArray<int3x3> output;

            public AverageJobHandle_int3x3(ref JobHandle handle, ref NativeArray<int3x3> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public int3x3 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static int3x3 Average<TSource>(
            this in ValueSequence<int3x3, TSource> source
            )
            where TSource : struct, ISequence<int3x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int3x3 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_int3x3<TSource>
            : IJob
            where TSource : struct, ISequence<int3x3>
        {
            [ReadOnly]
            public ValueSequence<int3x3, TSource> Source;

            [WriteOnly]
            public NativeArray<int3x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static int3x3 RunAverage<TSource>(
            this in ValueSequence<int3x3, TSource> source
            )
            where TSource : struct, ISequence<int3x3>
        {
            var output = new NativeArray<int3x3>(1, Allocator.Persistent);
            new AverageJob_int3x3<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<int3x3, TSource> source,
            in NativeArray<int3x3> output
            )
            where TSource : struct, ISequence<int3x3>
        {
            return new AverageJob_int3x3<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_int3x3 ScheduleAverage<TSource>(
            this in ValueSequence<int3x3, TSource> source
            )
            where TSource : struct, ISequence<int3x3>
        {
            var output = new NativeArray<int3x3>(1, Allocator.Persistent);
            var handle = new AverageJob_int3x3<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_int3x3(ref handle, ref output);
        }

        public static int3x3 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int3x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int3x3 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_int3x3<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3x3>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, int3x3>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<int3x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static int3x3 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int3x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3x3>
        {
            var output = new NativeArray<int3x3>(1, Allocator.Persistent);
            new AverageJobSelector_int3x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int3x3>.Struct<TSelector> selector,
            in NativeArray<int3x3> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3x3>
        {
            return new AverageJobSelector_int3x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_int3x3 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int3x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3x3>
        {
            var output = new NativeArray<int3x3>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_int3x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_int3x3(ref handle, ref output);
        }


        public struct AverageJobHandle_int3x4 : IDisposable
        {
            JobHandle handle;
            NativeArray<int3x4> output;

            public AverageJobHandle_int3x4(ref JobHandle handle, ref NativeArray<int3x4> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public int3x4 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static int3x4 Average<TSource>(
            this in ValueSequence<int3x4, TSource> source
            )
            where TSource : struct, ISequence<int3x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int3x4 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_int3x4<TSource>
            : IJob
            where TSource : struct, ISequence<int3x4>
        {
            [ReadOnly]
            public ValueSequence<int3x4, TSource> Source;

            [WriteOnly]
            public NativeArray<int3x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static int3x4 RunAverage<TSource>(
            this in ValueSequence<int3x4, TSource> source
            )
            where TSource : struct, ISequence<int3x4>
        {
            var output = new NativeArray<int3x4>(1, Allocator.Persistent);
            new AverageJob_int3x4<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<int3x4, TSource> source,
            in NativeArray<int3x4> output
            )
            where TSource : struct, ISequence<int3x4>
        {
            return new AverageJob_int3x4<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_int3x4 ScheduleAverage<TSource>(
            this in ValueSequence<int3x4, TSource> source
            )
            where TSource : struct, ISequence<int3x4>
        {
            var output = new NativeArray<int3x4>(1, Allocator.Persistent);
            var handle = new AverageJob_int3x4<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_int3x4(ref handle, ref output);
        }

        public static int3x4 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int3x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int3x4 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_int3x4<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3x4>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, int3x4>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<int3x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static int3x4 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int3x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3x4>
        {
            var output = new NativeArray<int3x4>(1, Allocator.Persistent);
            new AverageJobSelector_int3x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int3x4>.Struct<TSelector> selector,
            in NativeArray<int3x4> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3x4>
        {
            return new AverageJobSelector_int3x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_int3x4 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int3x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int3x4>
        {
            var output = new NativeArray<int3x4>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_int3x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_int3x4(ref handle, ref output);
        }


        public struct AverageJobHandle_int4 : IDisposable
        {
            JobHandle handle;
            NativeArray<int4> output;

            public AverageJobHandle_int4(ref JobHandle handle, ref NativeArray<int4> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public int4 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static int4 Average<TSource>(
            this in ValueSequence<int4, TSource> source
            )
            where TSource : struct, ISequence<int4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int4 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_int4<TSource>
            : IJob
            where TSource : struct, ISequence<int4>
        {
            [ReadOnly]
            public ValueSequence<int4, TSource> Source;

            [WriteOnly]
            public NativeArray<int4> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static int4 RunAverage<TSource>(
            this in ValueSequence<int4, TSource> source
            )
            where TSource : struct, ISequence<int4>
        {
            var output = new NativeArray<int4>(1, Allocator.Persistent);
            new AverageJob_int4<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<int4, TSource> source,
            in NativeArray<int4> output
            )
            where TSource : struct, ISequence<int4>
        {
            return new AverageJob_int4<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_int4 ScheduleAverage<TSource>(
            this in ValueSequence<int4, TSource> source
            )
            where TSource : struct, ISequence<int4>
        {
            var output = new NativeArray<int4>(1, Allocator.Persistent);
            var handle = new AverageJob_int4<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_int4(ref handle, ref output);
        }

        public static int4 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int4 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_int4<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, int4>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<int4> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static int4 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4>
        {
            var output = new NativeArray<int4>(1, Allocator.Persistent);
            new AverageJobSelector_int4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int4>.Struct<TSelector> selector,
            in NativeArray<int4> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4>
        {
            return new AverageJobSelector_int4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_int4 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4>
        {
            var output = new NativeArray<int4>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_int4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_int4(ref handle, ref output);
        }


        public struct AverageJobHandle_int4x2 : IDisposable
        {
            JobHandle handle;
            NativeArray<int4x2> output;

            public AverageJobHandle_int4x2(ref JobHandle handle, ref NativeArray<int4x2> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public int4x2 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static int4x2 Average<TSource>(
            this in ValueSequence<int4x2, TSource> source
            )
            where TSource : struct, ISequence<int4x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int4x2 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_int4x2<TSource>
            : IJob
            where TSource : struct, ISequence<int4x2>
        {
            [ReadOnly]
            public ValueSequence<int4x2, TSource> Source;

            [WriteOnly]
            public NativeArray<int4x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static int4x2 RunAverage<TSource>(
            this in ValueSequence<int4x2, TSource> source
            )
            where TSource : struct, ISequence<int4x2>
        {
            var output = new NativeArray<int4x2>(1, Allocator.Persistent);
            new AverageJob_int4x2<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<int4x2, TSource> source,
            in NativeArray<int4x2> output
            )
            where TSource : struct, ISequence<int4x2>
        {
            return new AverageJob_int4x2<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_int4x2 ScheduleAverage<TSource>(
            this in ValueSequence<int4x2, TSource> source
            )
            where TSource : struct, ISequence<int4x2>
        {
            var output = new NativeArray<int4x2>(1, Allocator.Persistent);
            var handle = new AverageJob_int4x2<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_int4x2(ref handle, ref output);
        }

        public static int4x2 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int4x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int4x2 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_int4x2<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4x2>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, int4x2>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<int4x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static int4x2 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int4x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4x2>
        {
            var output = new NativeArray<int4x2>(1, Allocator.Persistent);
            new AverageJobSelector_int4x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int4x2>.Struct<TSelector> selector,
            in NativeArray<int4x2> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4x2>
        {
            return new AverageJobSelector_int4x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_int4x2 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int4x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4x2>
        {
            var output = new NativeArray<int4x2>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_int4x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_int4x2(ref handle, ref output);
        }


        public struct AverageJobHandle_int4x3 : IDisposable
        {
            JobHandle handle;
            NativeArray<int4x3> output;

            public AverageJobHandle_int4x3(ref JobHandle handle, ref NativeArray<int4x3> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public int4x3 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static int4x3 Average<TSource>(
            this in ValueSequence<int4x3, TSource> source
            )
            where TSource : struct, ISequence<int4x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int4x3 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_int4x3<TSource>
            : IJob
            where TSource : struct, ISequence<int4x3>
        {
            [ReadOnly]
            public ValueSequence<int4x3, TSource> Source;

            [WriteOnly]
            public NativeArray<int4x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static int4x3 RunAverage<TSource>(
            this in ValueSequence<int4x3, TSource> source
            )
            where TSource : struct, ISequence<int4x3>
        {
            var output = new NativeArray<int4x3>(1, Allocator.Persistent);
            new AverageJob_int4x3<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<int4x3, TSource> source,
            in NativeArray<int4x3> output
            )
            where TSource : struct, ISequence<int4x3>
        {
            return new AverageJob_int4x3<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_int4x3 ScheduleAverage<TSource>(
            this in ValueSequence<int4x3, TSource> source
            )
            where TSource : struct, ISequence<int4x3>
        {
            var output = new NativeArray<int4x3>(1, Allocator.Persistent);
            var handle = new AverageJob_int4x3<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_int4x3(ref handle, ref output);
        }

        public static int4x3 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int4x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int4x3 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_int4x3<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4x3>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, int4x3>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<int4x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static int4x3 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int4x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4x3>
        {
            var output = new NativeArray<int4x3>(1, Allocator.Persistent);
            new AverageJobSelector_int4x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int4x3>.Struct<TSelector> selector,
            in NativeArray<int4x3> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4x3>
        {
            return new AverageJobSelector_int4x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_int4x3 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int4x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4x3>
        {
            var output = new NativeArray<int4x3>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_int4x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_int4x3(ref handle, ref output);
        }


        public struct AverageJobHandle_int4x4 : IDisposable
        {
            JobHandle handle;
            NativeArray<int4x4> output;

            public AverageJobHandle_int4x4(ref JobHandle handle, ref NativeArray<int4x4> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public int4x4 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static int4x4 Average<TSource>(
            this in ValueSequence<int4x4, TSource> source
            )
            where TSource : struct, ISequence<int4x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int4x4 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_int4x4<TSource>
            : IJob
            where TSource : struct, ISequence<int4x4>
        {
            [ReadOnly]
            public ValueSequence<int4x4, TSource> Source;

            [WriteOnly]
            public NativeArray<int4x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static int4x4 RunAverage<TSource>(
            this in ValueSequence<int4x4, TSource> source
            )
            where TSource : struct, ISequence<int4x4>
        {
            var output = new NativeArray<int4x4>(1, Allocator.Persistent);
            new AverageJob_int4x4<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<int4x4, TSource> source,
            in NativeArray<int4x4> output
            )
            where TSource : struct, ISequence<int4x4>
        {
            return new AverageJob_int4x4<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_int4x4 ScheduleAverage<TSource>(
            this in ValueSequence<int4x4, TSource> source
            )
            where TSource : struct, ISequence<int4x4>
        {
            var output = new NativeArray<int4x4>(1, Allocator.Persistent);
            var handle = new AverageJob_int4x4<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_int4x4(ref handle, ref output);
        }

        public static int4x4 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int4x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            int4x4 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_int4x4<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4x4>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, int4x4>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<int4x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static int4x4 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int4x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4x4>
        {
            var output = new NativeArray<int4x4>(1, Allocator.Persistent);
            new AverageJobSelector_int4x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int4x4>.Struct<TSelector> selector,
            in NativeArray<int4x4> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4x4>
        {
            return new AverageJobSelector_int4x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_int4x4 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, int4x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, int4x4>
        {
            var output = new NativeArray<int4x4>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_int4x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_int4x4(ref handle, ref output);
        }


        public struct AverageJobHandle_uint : IDisposable
        {
            JobHandle handle;
            NativeArray<uint> output;

            public AverageJobHandle_uint(ref JobHandle handle, ref NativeArray<uint> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public uint Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static uint Average<TSource>(
            this in ValueSequence<uint, TSource> source
            )
            where TSource : struct, ISequence<uint>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_uint<TSource>
            : IJob
            where TSource : struct, ISequence<uint>
        {
            [ReadOnly]
            public ValueSequence<uint, TSource> Source;

            [WriteOnly]
            public NativeArray<uint> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static uint RunAverage<TSource>(
            this in ValueSequence<uint, TSource> source
            )
            where TSource : struct, ISequence<uint>
        {
            var output = new NativeArray<uint>(1, Allocator.Persistent);
            new AverageJob_uint<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<uint, TSource> source,
            in NativeArray<uint> output
            )
            where TSource : struct, ISequence<uint>
        {
            return new AverageJob_uint<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint ScheduleAverage<TSource>(
            this in ValueSequence<uint, TSource> source
            )
            where TSource : struct, ISequence<uint>
        {
            var output = new NativeArray<uint>(1, Allocator.Persistent);
            var handle = new AverageJob_uint<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_uint(ref handle, ref output);
        }

        public static uint Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_uint<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, uint>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<uint> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static uint RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint>
        {
            var output = new NativeArray<uint>(1, Allocator.Persistent);
            new AverageJobSelector_uint<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint>.Struct<TSelector> selector,
            in NativeArray<uint> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint>
        {
            return new AverageJobSelector_uint<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint>
        {
            var output = new NativeArray<uint>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_uint<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_uint(ref handle, ref output);
        }


        public struct AverageJobHandle_uint2 : IDisposable
        {
            JobHandle handle;
            NativeArray<uint2> output;

            public AverageJobHandle_uint2(ref JobHandle handle, ref NativeArray<uint2> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public uint2 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static uint2 Average<TSource>(
            this in ValueSequence<uint2, TSource> source
            )
            where TSource : struct, ISequence<uint2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint2 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_uint2<TSource>
            : IJob
            where TSource : struct, ISequence<uint2>
        {
            [ReadOnly]
            public ValueSequence<uint2, TSource> Source;

            [WriteOnly]
            public NativeArray<uint2> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static uint2 RunAverage<TSource>(
            this in ValueSequence<uint2, TSource> source
            )
            where TSource : struct, ISequence<uint2>
        {
            var output = new NativeArray<uint2>(1, Allocator.Persistent);
            new AverageJob_uint2<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<uint2, TSource> source,
            in NativeArray<uint2> output
            )
            where TSource : struct, ISequence<uint2>
        {
            return new AverageJob_uint2<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint2 ScheduleAverage<TSource>(
            this in ValueSequence<uint2, TSource> source
            )
            where TSource : struct, ISequence<uint2>
        {
            var output = new NativeArray<uint2>(1, Allocator.Persistent);
            var handle = new AverageJob_uint2<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_uint2(ref handle, ref output);
        }

        public static uint2 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint2 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_uint2<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, uint2>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<uint2> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static uint2 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2>
        {
            var output = new NativeArray<uint2>(1, Allocator.Persistent);
            new AverageJobSelector_uint2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint2>.Struct<TSelector> selector,
            in NativeArray<uint2> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2>
        {
            return new AverageJobSelector_uint2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint2 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2>
        {
            var output = new NativeArray<uint2>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_uint2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_uint2(ref handle, ref output);
        }


        public struct AverageJobHandle_uint2x2 : IDisposable
        {
            JobHandle handle;
            NativeArray<uint2x2> output;

            public AverageJobHandle_uint2x2(ref JobHandle handle, ref NativeArray<uint2x2> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public uint2x2 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static uint2x2 Average<TSource>(
            this in ValueSequence<uint2x2, TSource> source
            )
            where TSource : struct, ISequence<uint2x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint2x2 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_uint2x2<TSource>
            : IJob
            where TSource : struct, ISequence<uint2x2>
        {
            [ReadOnly]
            public ValueSequence<uint2x2, TSource> Source;

            [WriteOnly]
            public NativeArray<uint2x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static uint2x2 RunAverage<TSource>(
            this in ValueSequence<uint2x2, TSource> source
            )
            where TSource : struct, ISequence<uint2x2>
        {
            var output = new NativeArray<uint2x2>(1, Allocator.Persistent);
            new AverageJob_uint2x2<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<uint2x2, TSource> source,
            in NativeArray<uint2x2> output
            )
            where TSource : struct, ISequence<uint2x2>
        {
            return new AverageJob_uint2x2<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint2x2 ScheduleAverage<TSource>(
            this in ValueSequence<uint2x2, TSource> source
            )
            where TSource : struct, ISequence<uint2x2>
        {
            var output = new NativeArray<uint2x2>(1, Allocator.Persistent);
            var handle = new AverageJob_uint2x2<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_uint2x2(ref handle, ref output);
        }

        public static uint2x2 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint2x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint2x2 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_uint2x2<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2x2>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, uint2x2>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<uint2x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static uint2x2 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint2x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2x2>
        {
            var output = new NativeArray<uint2x2>(1, Allocator.Persistent);
            new AverageJobSelector_uint2x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint2x2>.Struct<TSelector> selector,
            in NativeArray<uint2x2> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2x2>
        {
            return new AverageJobSelector_uint2x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint2x2 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint2x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2x2>
        {
            var output = new NativeArray<uint2x2>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_uint2x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_uint2x2(ref handle, ref output);
        }


        public struct AverageJobHandle_uint2x3 : IDisposable
        {
            JobHandle handle;
            NativeArray<uint2x3> output;

            public AverageJobHandle_uint2x3(ref JobHandle handle, ref NativeArray<uint2x3> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public uint2x3 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static uint2x3 Average<TSource>(
            this in ValueSequence<uint2x3, TSource> source
            )
            where TSource : struct, ISequence<uint2x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint2x3 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_uint2x3<TSource>
            : IJob
            where TSource : struct, ISequence<uint2x3>
        {
            [ReadOnly]
            public ValueSequence<uint2x3, TSource> Source;

            [WriteOnly]
            public NativeArray<uint2x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static uint2x3 RunAverage<TSource>(
            this in ValueSequence<uint2x3, TSource> source
            )
            where TSource : struct, ISequence<uint2x3>
        {
            var output = new NativeArray<uint2x3>(1, Allocator.Persistent);
            new AverageJob_uint2x3<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<uint2x3, TSource> source,
            in NativeArray<uint2x3> output
            )
            where TSource : struct, ISequence<uint2x3>
        {
            return new AverageJob_uint2x3<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint2x3 ScheduleAverage<TSource>(
            this in ValueSequence<uint2x3, TSource> source
            )
            where TSource : struct, ISequence<uint2x3>
        {
            var output = new NativeArray<uint2x3>(1, Allocator.Persistent);
            var handle = new AverageJob_uint2x3<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_uint2x3(ref handle, ref output);
        }

        public static uint2x3 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint2x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint2x3 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_uint2x3<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2x3>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, uint2x3>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<uint2x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static uint2x3 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint2x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2x3>
        {
            var output = new NativeArray<uint2x3>(1, Allocator.Persistent);
            new AverageJobSelector_uint2x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint2x3>.Struct<TSelector> selector,
            in NativeArray<uint2x3> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2x3>
        {
            return new AverageJobSelector_uint2x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint2x3 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint2x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2x3>
        {
            var output = new NativeArray<uint2x3>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_uint2x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_uint2x3(ref handle, ref output);
        }


        public struct AverageJobHandle_uint2x4 : IDisposable
        {
            JobHandle handle;
            NativeArray<uint2x4> output;

            public AverageJobHandle_uint2x4(ref JobHandle handle, ref NativeArray<uint2x4> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public uint2x4 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static uint2x4 Average<TSource>(
            this in ValueSequence<uint2x4, TSource> source
            )
            where TSource : struct, ISequence<uint2x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint2x4 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_uint2x4<TSource>
            : IJob
            where TSource : struct, ISequence<uint2x4>
        {
            [ReadOnly]
            public ValueSequence<uint2x4, TSource> Source;

            [WriteOnly]
            public NativeArray<uint2x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static uint2x4 RunAverage<TSource>(
            this in ValueSequence<uint2x4, TSource> source
            )
            where TSource : struct, ISequence<uint2x4>
        {
            var output = new NativeArray<uint2x4>(1, Allocator.Persistent);
            new AverageJob_uint2x4<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<uint2x4, TSource> source,
            in NativeArray<uint2x4> output
            )
            where TSource : struct, ISequence<uint2x4>
        {
            return new AverageJob_uint2x4<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint2x4 ScheduleAverage<TSource>(
            this in ValueSequence<uint2x4, TSource> source
            )
            where TSource : struct, ISequence<uint2x4>
        {
            var output = new NativeArray<uint2x4>(1, Allocator.Persistent);
            var handle = new AverageJob_uint2x4<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_uint2x4(ref handle, ref output);
        }

        public static uint2x4 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint2x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint2x4 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_uint2x4<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2x4>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, uint2x4>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<uint2x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static uint2x4 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint2x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2x4>
        {
            var output = new NativeArray<uint2x4>(1, Allocator.Persistent);
            new AverageJobSelector_uint2x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint2x4>.Struct<TSelector> selector,
            in NativeArray<uint2x4> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2x4>
        {
            return new AverageJobSelector_uint2x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint2x4 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint2x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint2x4>
        {
            var output = new NativeArray<uint2x4>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_uint2x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_uint2x4(ref handle, ref output);
        }


        public struct AverageJobHandle_uint3 : IDisposable
        {
            JobHandle handle;
            NativeArray<uint3> output;

            public AverageJobHandle_uint3(ref JobHandle handle, ref NativeArray<uint3> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public uint3 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static uint3 Average<TSource>(
            this in ValueSequence<uint3, TSource> source
            )
            where TSource : struct, ISequence<uint3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint3 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_uint3<TSource>
            : IJob
            where TSource : struct, ISequence<uint3>
        {
            [ReadOnly]
            public ValueSequence<uint3, TSource> Source;

            [WriteOnly]
            public NativeArray<uint3> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static uint3 RunAverage<TSource>(
            this in ValueSequence<uint3, TSource> source
            )
            where TSource : struct, ISequence<uint3>
        {
            var output = new NativeArray<uint3>(1, Allocator.Persistent);
            new AverageJob_uint3<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<uint3, TSource> source,
            in NativeArray<uint3> output
            )
            where TSource : struct, ISequence<uint3>
        {
            return new AverageJob_uint3<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint3 ScheduleAverage<TSource>(
            this in ValueSequence<uint3, TSource> source
            )
            where TSource : struct, ISequence<uint3>
        {
            var output = new NativeArray<uint3>(1, Allocator.Persistent);
            var handle = new AverageJob_uint3<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_uint3(ref handle, ref output);
        }

        public static uint3 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint3 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_uint3<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, uint3>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<uint3> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static uint3 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3>
        {
            var output = new NativeArray<uint3>(1, Allocator.Persistent);
            new AverageJobSelector_uint3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint3>.Struct<TSelector> selector,
            in NativeArray<uint3> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3>
        {
            return new AverageJobSelector_uint3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint3 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3>
        {
            var output = new NativeArray<uint3>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_uint3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_uint3(ref handle, ref output);
        }


        public struct AverageJobHandle_uint3x2 : IDisposable
        {
            JobHandle handle;
            NativeArray<uint3x2> output;

            public AverageJobHandle_uint3x2(ref JobHandle handle, ref NativeArray<uint3x2> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public uint3x2 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static uint3x2 Average<TSource>(
            this in ValueSequence<uint3x2, TSource> source
            )
            where TSource : struct, ISequence<uint3x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint3x2 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_uint3x2<TSource>
            : IJob
            where TSource : struct, ISequence<uint3x2>
        {
            [ReadOnly]
            public ValueSequence<uint3x2, TSource> Source;

            [WriteOnly]
            public NativeArray<uint3x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static uint3x2 RunAverage<TSource>(
            this in ValueSequence<uint3x2, TSource> source
            )
            where TSource : struct, ISequence<uint3x2>
        {
            var output = new NativeArray<uint3x2>(1, Allocator.Persistent);
            new AverageJob_uint3x2<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<uint3x2, TSource> source,
            in NativeArray<uint3x2> output
            )
            where TSource : struct, ISequence<uint3x2>
        {
            return new AverageJob_uint3x2<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint3x2 ScheduleAverage<TSource>(
            this in ValueSequence<uint3x2, TSource> source
            )
            where TSource : struct, ISequence<uint3x2>
        {
            var output = new NativeArray<uint3x2>(1, Allocator.Persistent);
            var handle = new AverageJob_uint3x2<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_uint3x2(ref handle, ref output);
        }

        public static uint3x2 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint3x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint3x2 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_uint3x2<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3x2>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, uint3x2>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<uint3x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static uint3x2 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint3x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3x2>
        {
            var output = new NativeArray<uint3x2>(1, Allocator.Persistent);
            new AverageJobSelector_uint3x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint3x2>.Struct<TSelector> selector,
            in NativeArray<uint3x2> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3x2>
        {
            return new AverageJobSelector_uint3x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint3x2 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint3x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3x2>
        {
            var output = new NativeArray<uint3x2>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_uint3x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_uint3x2(ref handle, ref output);
        }


        public struct AverageJobHandle_uint3x3 : IDisposable
        {
            JobHandle handle;
            NativeArray<uint3x3> output;

            public AverageJobHandle_uint3x3(ref JobHandle handle, ref NativeArray<uint3x3> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public uint3x3 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static uint3x3 Average<TSource>(
            this in ValueSequence<uint3x3, TSource> source
            )
            where TSource : struct, ISequence<uint3x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint3x3 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_uint3x3<TSource>
            : IJob
            where TSource : struct, ISequence<uint3x3>
        {
            [ReadOnly]
            public ValueSequence<uint3x3, TSource> Source;

            [WriteOnly]
            public NativeArray<uint3x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static uint3x3 RunAverage<TSource>(
            this in ValueSequence<uint3x3, TSource> source
            )
            where TSource : struct, ISequence<uint3x3>
        {
            var output = new NativeArray<uint3x3>(1, Allocator.Persistent);
            new AverageJob_uint3x3<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<uint3x3, TSource> source,
            in NativeArray<uint3x3> output
            )
            where TSource : struct, ISequence<uint3x3>
        {
            return new AverageJob_uint3x3<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint3x3 ScheduleAverage<TSource>(
            this in ValueSequence<uint3x3, TSource> source
            )
            where TSource : struct, ISequence<uint3x3>
        {
            var output = new NativeArray<uint3x3>(1, Allocator.Persistent);
            var handle = new AverageJob_uint3x3<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_uint3x3(ref handle, ref output);
        }

        public static uint3x3 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint3x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint3x3 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_uint3x3<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3x3>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, uint3x3>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<uint3x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static uint3x3 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint3x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3x3>
        {
            var output = new NativeArray<uint3x3>(1, Allocator.Persistent);
            new AverageJobSelector_uint3x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint3x3>.Struct<TSelector> selector,
            in NativeArray<uint3x3> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3x3>
        {
            return new AverageJobSelector_uint3x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint3x3 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint3x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3x3>
        {
            var output = new NativeArray<uint3x3>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_uint3x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_uint3x3(ref handle, ref output);
        }


        public struct AverageJobHandle_uint3x4 : IDisposable
        {
            JobHandle handle;
            NativeArray<uint3x4> output;

            public AverageJobHandle_uint3x4(ref JobHandle handle, ref NativeArray<uint3x4> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public uint3x4 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static uint3x4 Average<TSource>(
            this in ValueSequence<uint3x4, TSource> source
            )
            where TSource : struct, ISequence<uint3x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint3x4 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_uint3x4<TSource>
            : IJob
            where TSource : struct, ISequence<uint3x4>
        {
            [ReadOnly]
            public ValueSequence<uint3x4, TSource> Source;

            [WriteOnly]
            public NativeArray<uint3x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static uint3x4 RunAverage<TSource>(
            this in ValueSequence<uint3x4, TSource> source
            )
            where TSource : struct, ISequence<uint3x4>
        {
            var output = new NativeArray<uint3x4>(1, Allocator.Persistent);
            new AverageJob_uint3x4<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<uint3x4, TSource> source,
            in NativeArray<uint3x4> output
            )
            where TSource : struct, ISequence<uint3x4>
        {
            return new AverageJob_uint3x4<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint3x4 ScheduleAverage<TSource>(
            this in ValueSequence<uint3x4, TSource> source
            )
            where TSource : struct, ISequence<uint3x4>
        {
            var output = new NativeArray<uint3x4>(1, Allocator.Persistent);
            var handle = new AverageJob_uint3x4<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_uint3x4(ref handle, ref output);
        }

        public static uint3x4 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint3x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint3x4 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_uint3x4<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3x4>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, uint3x4>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<uint3x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static uint3x4 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint3x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3x4>
        {
            var output = new NativeArray<uint3x4>(1, Allocator.Persistent);
            new AverageJobSelector_uint3x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint3x4>.Struct<TSelector> selector,
            in NativeArray<uint3x4> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3x4>
        {
            return new AverageJobSelector_uint3x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint3x4 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint3x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint3x4>
        {
            var output = new NativeArray<uint3x4>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_uint3x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_uint3x4(ref handle, ref output);
        }


        public struct AverageJobHandle_uint4 : IDisposable
        {
            JobHandle handle;
            NativeArray<uint4> output;

            public AverageJobHandle_uint4(ref JobHandle handle, ref NativeArray<uint4> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public uint4 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static uint4 Average<TSource>(
            this in ValueSequence<uint4, TSource> source
            )
            where TSource : struct, ISequence<uint4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint4 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_uint4<TSource>
            : IJob
            where TSource : struct, ISequence<uint4>
        {
            [ReadOnly]
            public ValueSequence<uint4, TSource> Source;

            [WriteOnly]
            public NativeArray<uint4> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static uint4 RunAverage<TSource>(
            this in ValueSequence<uint4, TSource> source
            )
            where TSource : struct, ISequence<uint4>
        {
            var output = new NativeArray<uint4>(1, Allocator.Persistent);
            new AverageJob_uint4<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<uint4, TSource> source,
            in NativeArray<uint4> output
            )
            where TSource : struct, ISequence<uint4>
        {
            return new AverageJob_uint4<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint4 ScheduleAverage<TSource>(
            this in ValueSequence<uint4, TSource> source
            )
            where TSource : struct, ISequence<uint4>
        {
            var output = new NativeArray<uint4>(1, Allocator.Persistent);
            var handle = new AverageJob_uint4<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_uint4(ref handle, ref output);
        }

        public static uint4 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint4 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_uint4<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, uint4>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<uint4> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static uint4 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4>
        {
            var output = new NativeArray<uint4>(1, Allocator.Persistent);
            new AverageJobSelector_uint4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint4>.Struct<TSelector> selector,
            in NativeArray<uint4> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4>
        {
            return new AverageJobSelector_uint4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint4 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4>
        {
            var output = new NativeArray<uint4>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_uint4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_uint4(ref handle, ref output);
        }


        public struct AverageJobHandle_uint4x2 : IDisposable
        {
            JobHandle handle;
            NativeArray<uint4x2> output;

            public AverageJobHandle_uint4x2(ref JobHandle handle, ref NativeArray<uint4x2> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public uint4x2 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static uint4x2 Average<TSource>(
            this in ValueSequence<uint4x2, TSource> source
            )
            where TSource : struct, ISequence<uint4x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint4x2 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_uint4x2<TSource>
            : IJob
            where TSource : struct, ISequence<uint4x2>
        {
            [ReadOnly]
            public ValueSequence<uint4x2, TSource> Source;

            [WriteOnly]
            public NativeArray<uint4x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static uint4x2 RunAverage<TSource>(
            this in ValueSequence<uint4x2, TSource> source
            )
            where TSource : struct, ISequence<uint4x2>
        {
            var output = new NativeArray<uint4x2>(1, Allocator.Persistent);
            new AverageJob_uint4x2<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<uint4x2, TSource> source,
            in NativeArray<uint4x2> output
            )
            where TSource : struct, ISequence<uint4x2>
        {
            return new AverageJob_uint4x2<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint4x2 ScheduleAverage<TSource>(
            this in ValueSequence<uint4x2, TSource> source
            )
            where TSource : struct, ISequence<uint4x2>
        {
            var output = new NativeArray<uint4x2>(1, Allocator.Persistent);
            var handle = new AverageJob_uint4x2<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_uint4x2(ref handle, ref output);
        }

        public static uint4x2 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint4x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint4x2 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_uint4x2<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4x2>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, uint4x2>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<uint4x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static uint4x2 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint4x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4x2>
        {
            var output = new NativeArray<uint4x2>(1, Allocator.Persistent);
            new AverageJobSelector_uint4x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint4x2>.Struct<TSelector> selector,
            in NativeArray<uint4x2> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4x2>
        {
            return new AverageJobSelector_uint4x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint4x2 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint4x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4x2>
        {
            var output = new NativeArray<uint4x2>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_uint4x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_uint4x2(ref handle, ref output);
        }


        public struct AverageJobHandle_uint4x3 : IDisposable
        {
            JobHandle handle;
            NativeArray<uint4x3> output;

            public AverageJobHandle_uint4x3(ref JobHandle handle, ref NativeArray<uint4x3> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public uint4x3 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static uint4x3 Average<TSource>(
            this in ValueSequence<uint4x3, TSource> source
            )
            where TSource : struct, ISequence<uint4x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint4x3 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_uint4x3<TSource>
            : IJob
            where TSource : struct, ISequence<uint4x3>
        {
            [ReadOnly]
            public ValueSequence<uint4x3, TSource> Source;

            [WriteOnly]
            public NativeArray<uint4x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static uint4x3 RunAverage<TSource>(
            this in ValueSequence<uint4x3, TSource> source
            )
            where TSource : struct, ISequence<uint4x3>
        {
            var output = new NativeArray<uint4x3>(1, Allocator.Persistent);
            new AverageJob_uint4x3<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<uint4x3, TSource> source,
            in NativeArray<uint4x3> output
            )
            where TSource : struct, ISequence<uint4x3>
        {
            return new AverageJob_uint4x3<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint4x3 ScheduleAverage<TSource>(
            this in ValueSequence<uint4x3, TSource> source
            )
            where TSource : struct, ISequence<uint4x3>
        {
            var output = new NativeArray<uint4x3>(1, Allocator.Persistent);
            var handle = new AverageJob_uint4x3<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_uint4x3(ref handle, ref output);
        }

        public static uint4x3 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint4x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint4x3 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_uint4x3<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4x3>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, uint4x3>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<uint4x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static uint4x3 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint4x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4x3>
        {
            var output = new NativeArray<uint4x3>(1, Allocator.Persistent);
            new AverageJobSelector_uint4x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint4x3>.Struct<TSelector> selector,
            in NativeArray<uint4x3> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4x3>
        {
            return new AverageJobSelector_uint4x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint4x3 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint4x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4x3>
        {
            var output = new NativeArray<uint4x3>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_uint4x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_uint4x3(ref handle, ref output);
        }


        public struct AverageJobHandle_uint4x4 : IDisposable
        {
            JobHandle handle;
            NativeArray<uint4x4> output;

            public AverageJobHandle_uint4x4(ref JobHandle handle, ref NativeArray<uint4x4> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public uint4x4 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static uint4x4 Average<TSource>(
            this in ValueSequence<uint4x4, TSource> source
            )
            where TSource : struct, ISequence<uint4x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint4x4 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_uint4x4<TSource>
            : IJob
            where TSource : struct, ISequence<uint4x4>
        {
            [ReadOnly]
            public ValueSequence<uint4x4, TSource> Source;

            [WriteOnly]
            public NativeArray<uint4x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static uint4x4 RunAverage<TSource>(
            this in ValueSequence<uint4x4, TSource> source
            )
            where TSource : struct, ISequence<uint4x4>
        {
            var output = new NativeArray<uint4x4>(1, Allocator.Persistent);
            new AverageJob_uint4x4<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<uint4x4, TSource> source,
            in NativeArray<uint4x4> output
            )
            where TSource : struct, ISequence<uint4x4>
        {
            return new AverageJob_uint4x4<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint4x4 ScheduleAverage<TSource>(
            this in ValueSequence<uint4x4, TSource> source
            )
            where TSource : struct, ISequence<uint4x4>
        {
            var output = new NativeArray<uint4x4>(1, Allocator.Persistent);
            var handle = new AverageJob_uint4x4<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_uint4x4(ref handle, ref output);
        }

        public static uint4x4 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint4x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            uint4x4 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / (uint)srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_uint4x4<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4x4>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, uint4x4>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<uint4x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static uint4x4 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint4x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4x4>
        {
            var output = new NativeArray<uint4x4>(1, Allocator.Persistent);
            new AverageJobSelector_uint4x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint4x4>.Struct<TSelector> selector,
            in NativeArray<uint4x4> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4x4>
        {
            return new AverageJobSelector_uint4x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_uint4x4 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, uint4x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, uint4x4>
        {
            var output = new NativeArray<uint4x4>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_uint4x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_uint4x4(ref handle, ref output);
        }


        public struct AverageJobHandle_float : IDisposable
        {
            JobHandle handle;
            NativeArray<float> output;

            public AverageJobHandle_float(ref JobHandle handle, ref NativeArray<float> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public float Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static float Average<TSource>(
            this in ValueSequence<float, TSource> source
            )
            where TSource : struct, ISequence<float>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_float<TSource>
            : IJob
            where TSource : struct, ISequence<float>
        {
            [ReadOnly]
            public ValueSequence<float, TSource> Source;

            [WriteOnly]
            public NativeArray<float> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static float RunAverage<TSource>(
            this in ValueSequence<float, TSource> source
            )
            where TSource : struct, ISequence<float>
        {
            var output = new NativeArray<float>(1, Allocator.Persistent);
            new AverageJob_float<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<float, TSource> source,
            in NativeArray<float> output
            )
            where TSource : struct, ISequence<float>
        {
            return new AverageJob_float<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_float ScheduleAverage<TSource>(
            this in ValueSequence<float, TSource> source
            )
            where TSource : struct, ISequence<float>
        {
            var output = new NativeArray<float>(1, Allocator.Persistent);
            var handle = new AverageJob_float<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_float(ref handle, ref output);
        }

        public static float Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_float<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, float>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<float> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static float RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float>
        {
            var output = new NativeArray<float>(1, Allocator.Persistent);
            new AverageJobSelector_float<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float>.Struct<TSelector> selector,
            in NativeArray<float> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float>
        {
            return new AverageJobSelector_float<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_float ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float>
        {
            var output = new NativeArray<float>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_float<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_float(ref handle, ref output);
        }


        public struct AverageJobHandle_float2 : IDisposable
        {
            JobHandle handle;
            NativeArray<float2> output;

            public AverageJobHandle_float2(ref JobHandle handle, ref NativeArray<float2> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public float2 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static float2 Average<TSource>(
            this in ValueSequence<float2, TSource> source
            )
            where TSource : struct, ISequence<float2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float2 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_float2<TSource>
            : IJob
            where TSource : struct, ISequence<float2>
        {
            [ReadOnly]
            public ValueSequence<float2, TSource> Source;

            [WriteOnly]
            public NativeArray<float2> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static float2 RunAverage<TSource>(
            this in ValueSequence<float2, TSource> source
            )
            where TSource : struct, ISequence<float2>
        {
            var output = new NativeArray<float2>(1, Allocator.Persistent);
            new AverageJob_float2<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<float2, TSource> source,
            in NativeArray<float2> output
            )
            where TSource : struct, ISequence<float2>
        {
            return new AverageJob_float2<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_float2 ScheduleAverage<TSource>(
            this in ValueSequence<float2, TSource> source
            )
            where TSource : struct, ISequence<float2>
        {
            var output = new NativeArray<float2>(1, Allocator.Persistent);
            var handle = new AverageJob_float2<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_float2(ref handle, ref output);
        }

        public static float2 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float2 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_float2<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, float2>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<float2> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static float2 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2>
        {
            var output = new NativeArray<float2>(1, Allocator.Persistent);
            new AverageJobSelector_float2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float2>.Struct<TSelector> selector,
            in NativeArray<float2> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2>
        {
            return new AverageJobSelector_float2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_float2 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2>
        {
            var output = new NativeArray<float2>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_float2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_float2(ref handle, ref output);
        }


        public struct AverageJobHandle_float2x2 : IDisposable
        {
            JobHandle handle;
            NativeArray<float2x2> output;

            public AverageJobHandle_float2x2(ref JobHandle handle, ref NativeArray<float2x2> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public float2x2 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static float2x2 Average<TSource>(
            this in ValueSequence<float2x2, TSource> source
            )
            where TSource : struct, ISequence<float2x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float2x2 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_float2x2<TSource>
            : IJob
            where TSource : struct, ISequence<float2x2>
        {
            [ReadOnly]
            public ValueSequence<float2x2, TSource> Source;

            [WriteOnly]
            public NativeArray<float2x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static float2x2 RunAverage<TSource>(
            this in ValueSequence<float2x2, TSource> source
            )
            where TSource : struct, ISequence<float2x2>
        {
            var output = new NativeArray<float2x2>(1, Allocator.Persistent);
            new AverageJob_float2x2<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<float2x2, TSource> source,
            in NativeArray<float2x2> output
            )
            where TSource : struct, ISequence<float2x2>
        {
            return new AverageJob_float2x2<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_float2x2 ScheduleAverage<TSource>(
            this in ValueSequence<float2x2, TSource> source
            )
            where TSource : struct, ISequence<float2x2>
        {
            var output = new NativeArray<float2x2>(1, Allocator.Persistent);
            var handle = new AverageJob_float2x2<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_float2x2(ref handle, ref output);
        }

        public static float2x2 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float2x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float2x2 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_float2x2<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2x2>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, float2x2>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<float2x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static float2x2 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float2x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2x2>
        {
            var output = new NativeArray<float2x2>(1, Allocator.Persistent);
            new AverageJobSelector_float2x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float2x2>.Struct<TSelector> selector,
            in NativeArray<float2x2> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2x2>
        {
            return new AverageJobSelector_float2x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_float2x2 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float2x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2x2>
        {
            var output = new NativeArray<float2x2>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_float2x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_float2x2(ref handle, ref output);
        }


        public struct AverageJobHandle_float2x3 : IDisposable
        {
            JobHandle handle;
            NativeArray<float2x3> output;

            public AverageJobHandle_float2x3(ref JobHandle handle, ref NativeArray<float2x3> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public float2x3 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static float2x3 Average<TSource>(
            this in ValueSequence<float2x3, TSource> source
            )
            where TSource : struct, ISequence<float2x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float2x3 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_float2x3<TSource>
            : IJob
            where TSource : struct, ISequence<float2x3>
        {
            [ReadOnly]
            public ValueSequence<float2x3, TSource> Source;

            [WriteOnly]
            public NativeArray<float2x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static float2x3 RunAverage<TSource>(
            this in ValueSequence<float2x3, TSource> source
            )
            where TSource : struct, ISequence<float2x3>
        {
            var output = new NativeArray<float2x3>(1, Allocator.Persistent);
            new AverageJob_float2x3<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<float2x3, TSource> source,
            in NativeArray<float2x3> output
            )
            where TSource : struct, ISequence<float2x3>
        {
            return new AverageJob_float2x3<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_float2x3 ScheduleAverage<TSource>(
            this in ValueSequence<float2x3, TSource> source
            )
            where TSource : struct, ISequence<float2x3>
        {
            var output = new NativeArray<float2x3>(1, Allocator.Persistent);
            var handle = new AverageJob_float2x3<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_float2x3(ref handle, ref output);
        }

        public static float2x3 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float2x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float2x3 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_float2x3<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2x3>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, float2x3>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<float2x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static float2x3 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float2x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2x3>
        {
            var output = new NativeArray<float2x3>(1, Allocator.Persistent);
            new AverageJobSelector_float2x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float2x3>.Struct<TSelector> selector,
            in NativeArray<float2x3> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2x3>
        {
            return new AverageJobSelector_float2x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_float2x3 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float2x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2x3>
        {
            var output = new NativeArray<float2x3>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_float2x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_float2x3(ref handle, ref output);
        }


        public struct AverageJobHandle_float2x4 : IDisposable
        {
            JobHandle handle;
            NativeArray<float2x4> output;

            public AverageJobHandle_float2x4(ref JobHandle handle, ref NativeArray<float2x4> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public float2x4 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static float2x4 Average<TSource>(
            this in ValueSequence<float2x4, TSource> source
            )
            where TSource : struct, ISequence<float2x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float2x4 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_float2x4<TSource>
            : IJob
            where TSource : struct, ISequence<float2x4>
        {
            [ReadOnly]
            public ValueSequence<float2x4, TSource> Source;

            [WriteOnly]
            public NativeArray<float2x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static float2x4 RunAverage<TSource>(
            this in ValueSequence<float2x4, TSource> source
            )
            where TSource : struct, ISequence<float2x4>
        {
            var output = new NativeArray<float2x4>(1, Allocator.Persistent);
            new AverageJob_float2x4<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<float2x4, TSource> source,
            in NativeArray<float2x4> output
            )
            where TSource : struct, ISequence<float2x4>
        {
            return new AverageJob_float2x4<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_float2x4 ScheduleAverage<TSource>(
            this in ValueSequence<float2x4, TSource> source
            )
            where TSource : struct, ISequence<float2x4>
        {
            var output = new NativeArray<float2x4>(1, Allocator.Persistent);
            var handle = new AverageJob_float2x4<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_float2x4(ref handle, ref output);
        }

        public static float2x4 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float2x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float2x4 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_float2x4<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2x4>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, float2x4>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<float2x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static float2x4 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float2x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2x4>
        {
            var output = new NativeArray<float2x4>(1, Allocator.Persistent);
            new AverageJobSelector_float2x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float2x4>.Struct<TSelector> selector,
            in NativeArray<float2x4> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2x4>
        {
            return new AverageJobSelector_float2x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_float2x4 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float2x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float2x4>
        {
            var output = new NativeArray<float2x4>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_float2x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_float2x4(ref handle, ref output);
        }


        public struct AverageJobHandle_float3 : IDisposable
        {
            JobHandle handle;
            NativeArray<float3> output;

            public AverageJobHandle_float3(ref JobHandle handle, ref NativeArray<float3> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public float3 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static float3 Average<TSource>(
            this in ValueSequence<float3, TSource> source
            )
            where TSource : struct, ISequence<float3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float3 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_float3<TSource>
            : IJob
            where TSource : struct, ISequence<float3>
        {
            [ReadOnly]
            public ValueSequence<float3, TSource> Source;

            [WriteOnly]
            public NativeArray<float3> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static float3 RunAverage<TSource>(
            this in ValueSequence<float3, TSource> source
            )
            where TSource : struct, ISequence<float3>
        {
            var output = new NativeArray<float3>(1, Allocator.Persistent);
            new AverageJob_float3<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<float3, TSource> source,
            in NativeArray<float3> output
            )
            where TSource : struct, ISequence<float3>
        {
            return new AverageJob_float3<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_float3 ScheduleAverage<TSource>(
            this in ValueSequence<float3, TSource> source
            )
            where TSource : struct, ISequence<float3>
        {
            var output = new NativeArray<float3>(1, Allocator.Persistent);
            var handle = new AverageJob_float3<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_float3(ref handle, ref output);
        }

        public static float3 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float3 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_float3<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, float3>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<float3> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static float3 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3>
        {
            var output = new NativeArray<float3>(1, Allocator.Persistent);
            new AverageJobSelector_float3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float3>.Struct<TSelector> selector,
            in NativeArray<float3> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3>
        {
            return new AverageJobSelector_float3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_float3 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3>
        {
            var output = new NativeArray<float3>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_float3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_float3(ref handle, ref output);
        }


        public struct AverageJobHandle_float3x2 : IDisposable
        {
            JobHandle handle;
            NativeArray<float3x2> output;

            public AverageJobHandle_float3x2(ref JobHandle handle, ref NativeArray<float3x2> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public float3x2 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static float3x2 Average<TSource>(
            this in ValueSequence<float3x2, TSource> source
            )
            where TSource : struct, ISequence<float3x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float3x2 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_float3x2<TSource>
            : IJob
            where TSource : struct, ISequence<float3x2>
        {
            [ReadOnly]
            public ValueSequence<float3x2, TSource> Source;

            [WriteOnly]
            public NativeArray<float3x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static float3x2 RunAverage<TSource>(
            this in ValueSequence<float3x2, TSource> source
            )
            where TSource : struct, ISequence<float3x2>
        {
            var output = new NativeArray<float3x2>(1, Allocator.Persistent);
            new AverageJob_float3x2<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<float3x2, TSource> source,
            in NativeArray<float3x2> output
            )
            where TSource : struct, ISequence<float3x2>
        {
            return new AverageJob_float3x2<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_float3x2 ScheduleAverage<TSource>(
            this in ValueSequence<float3x2, TSource> source
            )
            where TSource : struct, ISequence<float3x2>
        {
            var output = new NativeArray<float3x2>(1, Allocator.Persistent);
            var handle = new AverageJob_float3x2<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_float3x2(ref handle, ref output);
        }

        public static float3x2 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float3x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float3x2 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_float3x2<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3x2>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, float3x2>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<float3x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static float3x2 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float3x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3x2>
        {
            var output = new NativeArray<float3x2>(1, Allocator.Persistent);
            new AverageJobSelector_float3x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float3x2>.Struct<TSelector> selector,
            in NativeArray<float3x2> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3x2>
        {
            return new AverageJobSelector_float3x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_float3x2 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float3x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3x2>
        {
            var output = new NativeArray<float3x2>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_float3x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_float3x2(ref handle, ref output);
        }


        public struct AverageJobHandle_float3x3 : IDisposable
        {
            JobHandle handle;
            NativeArray<float3x3> output;

            public AverageJobHandle_float3x3(ref JobHandle handle, ref NativeArray<float3x3> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public float3x3 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static float3x3 Average<TSource>(
            this in ValueSequence<float3x3, TSource> source
            )
            where TSource : struct, ISequence<float3x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float3x3 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_float3x3<TSource>
            : IJob
            where TSource : struct, ISequence<float3x3>
        {
            [ReadOnly]
            public ValueSequence<float3x3, TSource> Source;

            [WriteOnly]
            public NativeArray<float3x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static float3x3 RunAverage<TSource>(
            this in ValueSequence<float3x3, TSource> source
            )
            where TSource : struct, ISequence<float3x3>
        {
            var output = new NativeArray<float3x3>(1, Allocator.Persistent);
            new AverageJob_float3x3<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<float3x3, TSource> source,
            in NativeArray<float3x3> output
            )
            where TSource : struct, ISequence<float3x3>
        {
            return new AverageJob_float3x3<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_float3x3 ScheduleAverage<TSource>(
            this in ValueSequence<float3x3, TSource> source
            )
            where TSource : struct, ISequence<float3x3>
        {
            var output = new NativeArray<float3x3>(1, Allocator.Persistent);
            var handle = new AverageJob_float3x3<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_float3x3(ref handle, ref output);
        }

        public static float3x3 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float3x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float3x3 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_float3x3<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3x3>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, float3x3>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<float3x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static float3x3 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float3x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3x3>
        {
            var output = new NativeArray<float3x3>(1, Allocator.Persistent);
            new AverageJobSelector_float3x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float3x3>.Struct<TSelector> selector,
            in NativeArray<float3x3> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3x3>
        {
            return new AverageJobSelector_float3x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_float3x3 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float3x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3x3>
        {
            var output = new NativeArray<float3x3>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_float3x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_float3x3(ref handle, ref output);
        }


        public struct AverageJobHandle_float3x4 : IDisposable
        {
            JobHandle handle;
            NativeArray<float3x4> output;

            public AverageJobHandle_float3x4(ref JobHandle handle, ref NativeArray<float3x4> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public float3x4 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static float3x4 Average<TSource>(
            this in ValueSequence<float3x4, TSource> source
            )
            where TSource : struct, ISequence<float3x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float3x4 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_float3x4<TSource>
            : IJob
            where TSource : struct, ISequence<float3x4>
        {
            [ReadOnly]
            public ValueSequence<float3x4, TSource> Source;

            [WriteOnly]
            public NativeArray<float3x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static float3x4 RunAverage<TSource>(
            this in ValueSequence<float3x4, TSource> source
            )
            where TSource : struct, ISequence<float3x4>
        {
            var output = new NativeArray<float3x4>(1, Allocator.Persistent);
            new AverageJob_float3x4<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<float3x4, TSource> source,
            in NativeArray<float3x4> output
            )
            where TSource : struct, ISequence<float3x4>
        {
            return new AverageJob_float3x4<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_float3x4 ScheduleAverage<TSource>(
            this in ValueSequence<float3x4, TSource> source
            )
            where TSource : struct, ISequence<float3x4>
        {
            var output = new NativeArray<float3x4>(1, Allocator.Persistent);
            var handle = new AverageJob_float3x4<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_float3x4(ref handle, ref output);
        }

        public static float3x4 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float3x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float3x4 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_float3x4<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3x4>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, float3x4>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<float3x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static float3x4 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float3x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3x4>
        {
            var output = new NativeArray<float3x4>(1, Allocator.Persistent);
            new AverageJobSelector_float3x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float3x4>.Struct<TSelector> selector,
            in NativeArray<float3x4> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3x4>
        {
            return new AverageJobSelector_float3x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_float3x4 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float3x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float3x4>
        {
            var output = new NativeArray<float3x4>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_float3x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_float3x4(ref handle, ref output);
        }


        public struct AverageJobHandle_float4 : IDisposable
        {
            JobHandle handle;
            NativeArray<float4> output;

            public AverageJobHandle_float4(ref JobHandle handle, ref NativeArray<float4> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public float4 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static float4 Average<TSource>(
            this in ValueSequence<float4, TSource> source
            )
            where TSource : struct, ISequence<float4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float4 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_float4<TSource>
            : IJob
            where TSource : struct, ISequence<float4>
        {
            [ReadOnly]
            public ValueSequence<float4, TSource> Source;

            [WriteOnly]
            public NativeArray<float4> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static float4 RunAverage<TSource>(
            this in ValueSequence<float4, TSource> source
            )
            where TSource : struct, ISequence<float4>
        {
            var output = new NativeArray<float4>(1, Allocator.Persistent);
            new AverageJob_float4<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<float4, TSource> source,
            in NativeArray<float4> output
            )
            where TSource : struct, ISequence<float4>
        {
            return new AverageJob_float4<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_float4 ScheduleAverage<TSource>(
            this in ValueSequence<float4, TSource> source
            )
            where TSource : struct, ISequence<float4>
        {
            var output = new NativeArray<float4>(1, Allocator.Persistent);
            var handle = new AverageJob_float4<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_float4(ref handle, ref output);
        }

        public static float4 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float4 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_float4<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, float4>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<float4> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static float4 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4>
        {
            var output = new NativeArray<float4>(1, Allocator.Persistent);
            new AverageJobSelector_float4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float4>.Struct<TSelector> selector,
            in NativeArray<float4> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4>
        {
            return new AverageJobSelector_float4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_float4 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4>
        {
            var output = new NativeArray<float4>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_float4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_float4(ref handle, ref output);
        }


        public struct AverageJobHandle_float4x2 : IDisposable
        {
            JobHandle handle;
            NativeArray<float4x2> output;

            public AverageJobHandle_float4x2(ref JobHandle handle, ref NativeArray<float4x2> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public float4x2 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static float4x2 Average<TSource>(
            this in ValueSequence<float4x2, TSource> source
            )
            where TSource : struct, ISequence<float4x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float4x2 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_float4x2<TSource>
            : IJob
            where TSource : struct, ISequence<float4x2>
        {
            [ReadOnly]
            public ValueSequence<float4x2, TSource> Source;

            [WriteOnly]
            public NativeArray<float4x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static float4x2 RunAverage<TSource>(
            this in ValueSequence<float4x2, TSource> source
            )
            where TSource : struct, ISequence<float4x2>
        {
            var output = new NativeArray<float4x2>(1, Allocator.Persistent);
            new AverageJob_float4x2<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<float4x2, TSource> source,
            in NativeArray<float4x2> output
            )
            where TSource : struct, ISequence<float4x2>
        {
            return new AverageJob_float4x2<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_float4x2 ScheduleAverage<TSource>(
            this in ValueSequence<float4x2, TSource> source
            )
            where TSource : struct, ISequence<float4x2>
        {
            var output = new NativeArray<float4x2>(1, Allocator.Persistent);
            var handle = new AverageJob_float4x2<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_float4x2(ref handle, ref output);
        }

        public static float4x2 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float4x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float4x2 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_float4x2<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4x2>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, float4x2>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<float4x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static float4x2 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float4x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4x2>
        {
            var output = new NativeArray<float4x2>(1, Allocator.Persistent);
            new AverageJobSelector_float4x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float4x2>.Struct<TSelector> selector,
            in NativeArray<float4x2> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4x2>
        {
            return new AverageJobSelector_float4x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_float4x2 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float4x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4x2>
        {
            var output = new NativeArray<float4x2>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_float4x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_float4x2(ref handle, ref output);
        }


        public struct AverageJobHandle_float4x3 : IDisposable
        {
            JobHandle handle;
            NativeArray<float4x3> output;

            public AverageJobHandle_float4x3(ref JobHandle handle, ref NativeArray<float4x3> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public float4x3 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static float4x3 Average<TSource>(
            this in ValueSequence<float4x3, TSource> source
            )
            where TSource : struct, ISequence<float4x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float4x3 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_float4x3<TSource>
            : IJob
            where TSource : struct, ISequence<float4x3>
        {
            [ReadOnly]
            public ValueSequence<float4x3, TSource> Source;

            [WriteOnly]
            public NativeArray<float4x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static float4x3 RunAverage<TSource>(
            this in ValueSequence<float4x3, TSource> source
            )
            where TSource : struct, ISequence<float4x3>
        {
            var output = new NativeArray<float4x3>(1, Allocator.Persistent);
            new AverageJob_float4x3<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<float4x3, TSource> source,
            in NativeArray<float4x3> output
            )
            where TSource : struct, ISequence<float4x3>
        {
            return new AverageJob_float4x3<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_float4x3 ScheduleAverage<TSource>(
            this in ValueSequence<float4x3, TSource> source
            )
            where TSource : struct, ISequence<float4x3>
        {
            var output = new NativeArray<float4x3>(1, Allocator.Persistent);
            var handle = new AverageJob_float4x3<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_float4x3(ref handle, ref output);
        }

        public static float4x3 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float4x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float4x3 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_float4x3<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4x3>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, float4x3>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<float4x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static float4x3 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float4x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4x3>
        {
            var output = new NativeArray<float4x3>(1, Allocator.Persistent);
            new AverageJobSelector_float4x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float4x3>.Struct<TSelector> selector,
            in NativeArray<float4x3> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4x3>
        {
            return new AverageJobSelector_float4x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_float4x3 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float4x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4x3>
        {
            var output = new NativeArray<float4x3>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_float4x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_float4x3(ref handle, ref output);
        }


        public struct AverageJobHandle_float4x4 : IDisposable
        {
            JobHandle handle;
            NativeArray<float4x4> output;

            public AverageJobHandle_float4x4(ref JobHandle handle, ref NativeArray<float4x4> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public float4x4 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static float4x4 Average<TSource>(
            this in ValueSequence<float4x4, TSource> source
            )
            where TSource : struct, ISequence<float4x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float4x4 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_float4x4<TSource>
            : IJob
            where TSource : struct, ISequence<float4x4>
        {
            [ReadOnly]
            public ValueSequence<float4x4, TSource> Source;

            [WriteOnly]
            public NativeArray<float4x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static float4x4 RunAverage<TSource>(
            this in ValueSequence<float4x4, TSource> source
            )
            where TSource : struct, ISequence<float4x4>
        {
            var output = new NativeArray<float4x4>(1, Allocator.Persistent);
            new AverageJob_float4x4<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<float4x4, TSource> source,
            in NativeArray<float4x4> output
            )
            where TSource : struct, ISequence<float4x4>
        {
            return new AverageJob_float4x4<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_float4x4 ScheduleAverage<TSource>(
            this in ValueSequence<float4x4, TSource> source
            )
            where TSource : struct, ISequence<float4x4>
        {
            var output = new NativeArray<float4x4>(1, Allocator.Persistent);
            var handle = new AverageJob_float4x4<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_float4x4(ref handle, ref output);
        }

        public static float4x4 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float4x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            float4x4 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_float4x4<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4x4>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, float4x4>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<float4x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static float4x4 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float4x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4x4>
        {
            var output = new NativeArray<float4x4>(1, Allocator.Persistent);
            new AverageJobSelector_float4x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float4x4>.Struct<TSelector> selector,
            in NativeArray<float4x4> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4x4>
        {
            return new AverageJobSelector_float4x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_float4x4 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, float4x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, float4x4>
        {
            var output = new NativeArray<float4x4>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_float4x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_float4x4(ref handle, ref output);
        }


        public struct AverageJobHandle_double : IDisposable
        {
            JobHandle handle;
            NativeArray<double> output;

            public AverageJobHandle_double(ref JobHandle handle, ref NativeArray<double> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public double Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static double Average<TSource>(
            this in ValueSequence<double, TSource> source
            )
            where TSource : struct, ISequence<double>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_double<TSource>
            : IJob
            where TSource : struct, ISequence<double>
        {
            [ReadOnly]
            public ValueSequence<double, TSource> Source;

            [WriteOnly]
            public NativeArray<double> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static double RunAverage<TSource>(
            this in ValueSequence<double, TSource> source
            )
            where TSource : struct, ISequence<double>
        {
            var output = new NativeArray<double>(1, Allocator.Persistent);
            new AverageJob_double<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<double, TSource> source,
            in NativeArray<double> output
            )
            where TSource : struct, ISequence<double>
        {
            return new AverageJob_double<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_double ScheduleAverage<TSource>(
            this in ValueSequence<double, TSource> source
            )
            where TSource : struct, ISequence<double>
        {
            var output = new NativeArray<double>(1, Allocator.Persistent);
            var handle = new AverageJob_double<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_double(ref handle, ref output);
        }

        public static double Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_double<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, double>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<double> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static double RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double>
        {
            var output = new NativeArray<double>(1, Allocator.Persistent);
            new AverageJobSelector_double<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double>.Struct<TSelector> selector,
            in NativeArray<double> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double>
        {
            return new AverageJobSelector_double<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_double ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double>
        {
            var output = new NativeArray<double>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_double<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_double(ref handle, ref output);
        }


        public struct AverageJobHandle_double2 : IDisposable
        {
            JobHandle handle;
            NativeArray<double2> output;

            public AverageJobHandle_double2(ref JobHandle handle, ref NativeArray<double2> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public double2 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static double2 Average<TSource>(
            this in ValueSequence<double2, TSource> source
            )
            where TSource : struct, ISequence<double2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double2 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_double2<TSource>
            : IJob
            where TSource : struct, ISequence<double2>
        {
            [ReadOnly]
            public ValueSequence<double2, TSource> Source;

            [WriteOnly]
            public NativeArray<double2> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static double2 RunAverage<TSource>(
            this in ValueSequence<double2, TSource> source
            )
            where TSource : struct, ISequence<double2>
        {
            var output = new NativeArray<double2>(1, Allocator.Persistent);
            new AverageJob_double2<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<double2, TSource> source,
            in NativeArray<double2> output
            )
            where TSource : struct, ISequence<double2>
        {
            return new AverageJob_double2<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_double2 ScheduleAverage<TSource>(
            this in ValueSequence<double2, TSource> source
            )
            where TSource : struct, ISequence<double2>
        {
            var output = new NativeArray<double2>(1, Allocator.Persistent);
            var handle = new AverageJob_double2<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_double2(ref handle, ref output);
        }

        public static double2 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double2 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_double2<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, double2>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<double2> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static double2 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2>
        {
            var output = new NativeArray<double2>(1, Allocator.Persistent);
            new AverageJobSelector_double2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double2>.Struct<TSelector> selector,
            in NativeArray<double2> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2>
        {
            return new AverageJobSelector_double2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_double2 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2>
        {
            var output = new NativeArray<double2>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_double2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_double2(ref handle, ref output);
        }


        public struct AverageJobHandle_double2x2 : IDisposable
        {
            JobHandle handle;
            NativeArray<double2x2> output;

            public AverageJobHandle_double2x2(ref JobHandle handle, ref NativeArray<double2x2> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public double2x2 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static double2x2 Average<TSource>(
            this in ValueSequence<double2x2, TSource> source
            )
            where TSource : struct, ISequence<double2x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double2x2 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_double2x2<TSource>
            : IJob
            where TSource : struct, ISequence<double2x2>
        {
            [ReadOnly]
            public ValueSequence<double2x2, TSource> Source;

            [WriteOnly]
            public NativeArray<double2x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static double2x2 RunAverage<TSource>(
            this in ValueSequence<double2x2, TSource> source
            )
            where TSource : struct, ISequence<double2x2>
        {
            var output = new NativeArray<double2x2>(1, Allocator.Persistent);
            new AverageJob_double2x2<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<double2x2, TSource> source,
            in NativeArray<double2x2> output
            )
            where TSource : struct, ISequence<double2x2>
        {
            return new AverageJob_double2x2<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_double2x2 ScheduleAverage<TSource>(
            this in ValueSequence<double2x2, TSource> source
            )
            where TSource : struct, ISequence<double2x2>
        {
            var output = new NativeArray<double2x2>(1, Allocator.Persistent);
            var handle = new AverageJob_double2x2<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_double2x2(ref handle, ref output);
        }

        public static double2x2 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double2x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double2x2 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_double2x2<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2x2>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, double2x2>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<double2x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static double2x2 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double2x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2x2>
        {
            var output = new NativeArray<double2x2>(1, Allocator.Persistent);
            new AverageJobSelector_double2x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double2x2>.Struct<TSelector> selector,
            in NativeArray<double2x2> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2x2>
        {
            return new AverageJobSelector_double2x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_double2x2 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double2x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2x2>
        {
            var output = new NativeArray<double2x2>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_double2x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_double2x2(ref handle, ref output);
        }


        public struct AverageJobHandle_double2x3 : IDisposable
        {
            JobHandle handle;
            NativeArray<double2x3> output;

            public AverageJobHandle_double2x3(ref JobHandle handle, ref NativeArray<double2x3> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public double2x3 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static double2x3 Average<TSource>(
            this in ValueSequence<double2x3, TSource> source
            )
            where TSource : struct, ISequence<double2x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double2x3 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_double2x3<TSource>
            : IJob
            where TSource : struct, ISequence<double2x3>
        {
            [ReadOnly]
            public ValueSequence<double2x3, TSource> Source;

            [WriteOnly]
            public NativeArray<double2x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static double2x3 RunAverage<TSource>(
            this in ValueSequence<double2x3, TSource> source
            )
            where TSource : struct, ISequence<double2x3>
        {
            var output = new NativeArray<double2x3>(1, Allocator.Persistent);
            new AverageJob_double2x3<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<double2x3, TSource> source,
            in NativeArray<double2x3> output
            )
            where TSource : struct, ISequence<double2x3>
        {
            return new AverageJob_double2x3<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_double2x3 ScheduleAverage<TSource>(
            this in ValueSequence<double2x3, TSource> source
            )
            where TSource : struct, ISequence<double2x3>
        {
            var output = new NativeArray<double2x3>(1, Allocator.Persistent);
            var handle = new AverageJob_double2x3<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_double2x3(ref handle, ref output);
        }

        public static double2x3 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double2x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double2x3 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_double2x3<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2x3>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, double2x3>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<double2x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static double2x3 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double2x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2x3>
        {
            var output = new NativeArray<double2x3>(1, Allocator.Persistent);
            new AverageJobSelector_double2x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double2x3>.Struct<TSelector> selector,
            in NativeArray<double2x3> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2x3>
        {
            return new AverageJobSelector_double2x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_double2x3 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double2x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2x3>
        {
            var output = new NativeArray<double2x3>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_double2x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_double2x3(ref handle, ref output);
        }


        public struct AverageJobHandle_double2x4 : IDisposable
        {
            JobHandle handle;
            NativeArray<double2x4> output;

            public AverageJobHandle_double2x4(ref JobHandle handle, ref NativeArray<double2x4> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public double2x4 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static double2x4 Average<TSource>(
            this in ValueSequence<double2x4, TSource> source
            )
            where TSource : struct, ISequence<double2x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double2x4 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_double2x4<TSource>
            : IJob
            where TSource : struct, ISequence<double2x4>
        {
            [ReadOnly]
            public ValueSequence<double2x4, TSource> Source;

            [WriteOnly]
            public NativeArray<double2x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static double2x4 RunAverage<TSource>(
            this in ValueSequence<double2x4, TSource> source
            )
            where TSource : struct, ISequence<double2x4>
        {
            var output = new NativeArray<double2x4>(1, Allocator.Persistent);
            new AverageJob_double2x4<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<double2x4, TSource> source,
            in NativeArray<double2x4> output
            )
            where TSource : struct, ISequence<double2x4>
        {
            return new AverageJob_double2x4<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_double2x4 ScheduleAverage<TSource>(
            this in ValueSequence<double2x4, TSource> source
            )
            where TSource : struct, ISequence<double2x4>
        {
            var output = new NativeArray<double2x4>(1, Allocator.Persistent);
            var handle = new AverageJob_double2x4<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_double2x4(ref handle, ref output);
        }

        public static double2x4 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double2x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double2x4 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_double2x4<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2x4>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, double2x4>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<double2x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static double2x4 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double2x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2x4>
        {
            var output = new NativeArray<double2x4>(1, Allocator.Persistent);
            new AverageJobSelector_double2x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double2x4>.Struct<TSelector> selector,
            in NativeArray<double2x4> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2x4>
        {
            return new AverageJobSelector_double2x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_double2x4 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double2x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double2x4>
        {
            var output = new NativeArray<double2x4>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_double2x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_double2x4(ref handle, ref output);
        }


        public struct AverageJobHandle_double3 : IDisposable
        {
            JobHandle handle;
            NativeArray<double3> output;

            public AverageJobHandle_double3(ref JobHandle handle, ref NativeArray<double3> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public double3 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static double3 Average<TSource>(
            this in ValueSequence<double3, TSource> source
            )
            where TSource : struct, ISequence<double3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double3 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_double3<TSource>
            : IJob
            where TSource : struct, ISequence<double3>
        {
            [ReadOnly]
            public ValueSequence<double3, TSource> Source;

            [WriteOnly]
            public NativeArray<double3> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static double3 RunAverage<TSource>(
            this in ValueSequence<double3, TSource> source
            )
            where TSource : struct, ISequence<double3>
        {
            var output = new NativeArray<double3>(1, Allocator.Persistent);
            new AverageJob_double3<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<double3, TSource> source,
            in NativeArray<double3> output
            )
            where TSource : struct, ISequence<double3>
        {
            return new AverageJob_double3<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_double3 ScheduleAverage<TSource>(
            this in ValueSequence<double3, TSource> source
            )
            where TSource : struct, ISequence<double3>
        {
            var output = new NativeArray<double3>(1, Allocator.Persistent);
            var handle = new AverageJob_double3<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_double3(ref handle, ref output);
        }

        public static double3 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double3 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_double3<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, double3>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<double3> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static double3 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3>
        {
            var output = new NativeArray<double3>(1, Allocator.Persistent);
            new AverageJobSelector_double3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double3>.Struct<TSelector> selector,
            in NativeArray<double3> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3>
        {
            return new AverageJobSelector_double3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_double3 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3>
        {
            var output = new NativeArray<double3>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_double3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_double3(ref handle, ref output);
        }


        public struct AverageJobHandle_double3x2 : IDisposable
        {
            JobHandle handle;
            NativeArray<double3x2> output;

            public AverageJobHandle_double3x2(ref JobHandle handle, ref NativeArray<double3x2> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public double3x2 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static double3x2 Average<TSource>(
            this in ValueSequence<double3x2, TSource> source
            )
            where TSource : struct, ISequence<double3x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double3x2 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_double3x2<TSource>
            : IJob
            where TSource : struct, ISequence<double3x2>
        {
            [ReadOnly]
            public ValueSequence<double3x2, TSource> Source;

            [WriteOnly]
            public NativeArray<double3x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static double3x2 RunAverage<TSource>(
            this in ValueSequence<double3x2, TSource> source
            )
            where TSource : struct, ISequence<double3x2>
        {
            var output = new NativeArray<double3x2>(1, Allocator.Persistent);
            new AverageJob_double3x2<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<double3x2, TSource> source,
            in NativeArray<double3x2> output
            )
            where TSource : struct, ISequence<double3x2>
        {
            return new AverageJob_double3x2<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_double3x2 ScheduleAverage<TSource>(
            this in ValueSequence<double3x2, TSource> source
            )
            where TSource : struct, ISequence<double3x2>
        {
            var output = new NativeArray<double3x2>(1, Allocator.Persistent);
            var handle = new AverageJob_double3x2<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_double3x2(ref handle, ref output);
        }

        public static double3x2 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double3x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double3x2 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_double3x2<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3x2>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, double3x2>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<double3x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static double3x2 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double3x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3x2>
        {
            var output = new NativeArray<double3x2>(1, Allocator.Persistent);
            new AverageJobSelector_double3x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double3x2>.Struct<TSelector> selector,
            in NativeArray<double3x2> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3x2>
        {
            return new AverageJobSelector_double3x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_double3x2 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double3x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3x2>
        {
            var output = new NativeArray<double3x2>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_double3x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_double3x2(ref handle, ref output);
        }


        public struct AverageJobHandle_double3x3 : IDisposable
        {
            JobHandle handle;
            NativeArray<double3x3> output;

            public AverageJobHandle_double3x3(ref JobHandle handle, ref NativeArray<double3x3> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public double3x3 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static double3x3 Average<TSource>(
            this in ValueSequence<double3x3, TSource> source
            )
            where TSource : struct, ISequence<double3x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double3x3 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_double3x3<TSource>
            : IJob
            where TSource : struct, ISequence<double3x3>
        {
            [ReadOnly]
            public ValueSequence<double3x3, TSource> Source;

            [WriteOnly]
            public NativeArray<double3x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static double3x3 RunAverage<TSource>(
            this in ValueSequence<double3x3, TSource> source
            )
            where TSource : struct, ISequence<double3x3>
        {
            var output = new NativeArray<double3x3>(1, Allocator.Persistent);
            new AverageJob_double3x3<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<double3x3, TSource> source,
            in NativeArray<double3x3> output
            )
            where TSource : struct, ISequence<double3x3>
        {
            return new AverageJob_double3x3<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_double3x3 ScheduleAverage<TSource>(
            this in ValueSequence<double3x3, TSource> source
            )
            where TSource : struct, ISequence<double3x3>
        {
            var output = new NativeArray<double3x3>(1, Allocator.Persistent);
            var handle = new AverageJob_double3x3<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_double3x3(ref handle, ref output);
        }

        public static double3x3 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double3x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double3x3 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_double3x3<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3x3>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, double3x3>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<double3x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static double3x3 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double3x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3x3>
        {
            var output = new NativeArray<double3x3>(1, Allocator.Persistent);
            new AverageJobSelector_double3x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double3x3>.Struct<TSelector> selector,
            in NativeArray<double3x3> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3x3>
        {
            return new AverageJobSelector_double3x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_double3x3 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double3x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3x3>
        {
            var output = new NativeArray<double3x3>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_double3x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_double3x3(ref handle, ref output);
        }


        public struct AverageJobHandle_double3x4 : IDisposable
        {
            JobHandle handle;
            NativeArray<double3x4> output;

            public AverageJobHandle_double3x4(ref JobHandle handle, ref NativeArray<double3x4> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public double3x4 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static double3x4 Average<TSource>(
            this in ValueSequence<double3x4, TSource> source
            )
            where TSource : struct, ISequence<double3x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double3x4 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_double3x4<TSource>
            : IJob
            where TSource : struct, ISequence<double3x4>
        {
            [ReadOnly]
            public ValueSequence<double3x4, TSource> Source;

            [WriteOnly]
            public NativeArray<double3x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static double3x4 RunAverage<TSource>(
            this in ValueSequence<double3x4, TSource> source
            )
            where TSource : struct, ISequence<double3x4>
        {
            var output = new NativeArray<double3x4>(1, Allocator.Persistent);
            new AverageJob_double3x4<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<double3x4, TSource> source,
            in NativeArray<double3x4> output
            )
            where TSource : struct, ISequence<double3x4>
        {
            return new AverageJob_double3x4<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_double3x4 ScheduleAverage<TSource>(
            this in ValueSequence<double3x4, TSource> source
            )
            where TSource : struct, ISequence<double3x4>
        {
            var output = new NativeArray<double3x4>(1, Allocator.Persistent);
            var handle = new AverageJob_double3x4<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_double3x4(ref handle, ref output);
        }

        public static double3x4 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double3x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double3x4 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_double3x4<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3x4>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, double3x4>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<double3x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static double3x4 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double3x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3x4>
        {
            var output = new NativeArray<double3x4>(1, Allocator.Persistent);
            new AverageJobSelector_double3x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double3x4>.Struct<TSelector> selector,
            in NativeArray<double3x4> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3x4>
        {
            return new AverageJobSelector_double3x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_double3x4 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double3x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double3x4>
        {
            var output = new NativeArray<double3x4>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_double3x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_double3x4(ref handle, ref output);
        }


        public struct AverageJobHandle_double4 : IDisposable
        {
            JobHandle handle;
            NativeArray<double4> output;

            public AverageJobHandle_double4(ref JobHandle handle, ref NativeArray<double4> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public double4 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static double4 Average<TSource>(
            this in ValueSequence<double4, TSource> source
            )
            where TSource : struct, ISequence<double4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double4 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_double4<TSource>
            : IJob
            where TSource : struct, ISequence<double4>
        {
            [ReadOnly]
            public ValueSequence<double4, TSource> Source;

            [WriteOnly]
            public NativeArray<double4> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static double4 RunAverage<TSource>(
            this in ValueSequence<double4, TSource> source
            )
            where TSource : struct, ISequence<double4>
        {
            var output = new NativeArray<double4>(1, Allocator.Persistent);
            new AverageJob_double4<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<double4, TSource> source,
            in NativeArray<double4> output
            )
            where TSource : struct, ISequence<double4>
        {
            return new AverageJob_double4<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_double4 ScheduleAverage<TSource>(
            this in ValueSequence<double4, TSource> source
            )
            where TSource : struct, ISequence<double4>
        {
            var output = new NativeArray<double4>(1, Allocator.Persistent);
            var handle = new AverageJob_double4<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_double4(ref handle, ref output);
        }

        public static double4 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double4 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_double4<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, double4>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<double4> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static double4 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4>
        {
            var output = new NativeArray<double4>(1, Allocator.Persistent);
            new AverageJobSelector_double4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double4>.Struct<TSelector> selector,
            in NativeArray<double4> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4>
        {
            return new AverageJobSelector_double4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_double4 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4>
        {
            var output = new NativeArray<double4>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_double4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_double4(ref handle, ref output);
        }


        public struct AverageJobHandle_double4x2 : IDisposable
        {
            JobHandle handle;
            NativeArray<double4x2> output;

            public AverageJobHandle_double4x2(ref JobHandle handle, ref NativeArray<double4x2> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public double4x2 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static double4x2 Average<TSource>(
            this in ValueSequence<double4x2, TSource> source
            )
            where TSource : struct, ISequence<double4x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double4x2 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_double4x2<TSource>
            : IJob
            where TSource : struct, ISequence<double4x2>
        {
            [ReadOnly]
            public ValueSequence<double4x2, TSource> Source;

            [WriteOnly]
            public NativeArray<double4x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static double4x2 RunAverage<TSource>(
            this in ValueSequence<double4x2, TSource> source
            )
            where TSource : struct, ISequence<double4x2>
        {
            var output = new NativeArray<double4x2>(1, Allocator.Persistent);
            new AverageJob_double4x2<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<double4x2, TSource> source,
            in NativeArray<double4x2> output
            )
            where TSource : struct, ISequence<double4x2>
        {
            return new AverageJob_double4x2<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_double4x2 ScheduleAverage<TSource>(
            this in ValueSequence<double4x2, TSource> source
            )
            where TSource : struct, ISequence<double4x2>
        {
            var output = new NativeArray<double4x2>(1, Allocator.Persistent);
            var handle = new AverageJob_double4x2<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_double4x2(ref handle, ref output);
        }

        public static double4x2 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double4x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4x2>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double4x2 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_double4x2<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4x2>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, double4x2>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<double4x2> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static double4x2 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double4x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4x2>
        {
            var output = new NativeArray<double4x2>(1, Allocator.Persistent);
            new AverageJobSelector_double4x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double4x2>.Struct<TSelector> selector,
            in NativeArray<double4x2> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4x2>
        {
            return new AverageJobSelector_double4x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_double4x2 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double4x2>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4x2>
        {
            var output = new NativeArray<double4x2>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_double4x2<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_double4x2(ref handle, ref output);
        }


        public struct AverageJobHandle_double4x3 : IDisposable
        {
            JobHandle handle;
            NativeArray<double4x3> output;

            public AverageJobHandle_double4x3(ref JobHandle handle, ref NativeArray<double4x3> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public double4x3 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static double4x3 Average<TSource>(
            this in ValueSequence<double4x3, TSource> source
            )
            where TSource : struct, ISequence<double4x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double4x3 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_double4x3<TSource>
            : IJob
            where TSource : struct, ISequence<double4x3>
        {
            [ReadOnly]
            public ValueSequence<double4x3, TSource> Source;

            [WriteOnly]
            public NativeArray<double4x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static double4x3 RunAverage<TSource>(
            this in ValueSequence<double4x3, TSource> source
            )
            where TSource : struct, ISequence<double4x3>
        {
            var output = new NativeArray<double4x3>(1, Allocator.Persistent);
            new AverageJob_double4x3<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<double4x3, TSource> source,
            in NativeArray<double4x3> output
            )
            where TSource : struct, ISequence<double4x3>
        {
            return new AverageJob_double4x3<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_double4x3 ScheduleAverage<TSource>(
            this in ValueSequence<double4x3, TSource> source
            )
            where TSource : struct, ISequence<double4x3>
        {
            var output = new NativeArray<double4x3>(1, Allocator.Persistent);
            var handle = new AverageJob_double4x3<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_double4x3(ref handle, ref output);
        }

        public static double4x3 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double4x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4x3>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double4x3 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_double4x3<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4x3>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, double4x3>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<double4x3> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static double4x3 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double4x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4x3>
        {
            var output = new NativeArray<double4x3>(1, Allocator.Persistent);
            new AverageJobSelector_double4x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double4x3>.Struct<TSelector> selector,
            in NativeArray<double4x3> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4x3>
        {
            return new AverageJobSelector_double4x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_double4x3 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double4x3>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4x3>
        {
            var output = new NativeArray<double4x3>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_double4x3<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_double4x3(ref handle, ref output);
        }


        public struct AverageJobHandle_double4x4 : IDisposable
        {
            JobHandle handle;
            NativeArray<double4x4> output;

            public AverageJobHandle_double4x4(ref JobHandle handle, ref NativeArray<double4x4> output)
            {
                this.handle = handle;
                this.output = output;
            }

            public double4x4 Complete()
            {
                handle.Complete();
                var result = output[0];
                Dispose();
                return result;
            }

            public void Dispose()
            {
                if (output.IsCreated)
                    output.Dispose();
                output = default;
            }
        }

        public static double4x4 Average<TSource>(
            this in ValueSequence<double4x4, TSource> source
            )
            where TSource : struct, ISequence<double4x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double4x4 sum = srcList[0];
            for (var i = 1; i < srcList.Length; i++)
                sum += srcList[i];
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJob_double4x4<TSource>
            : IJob
            where TSource : struct, ISequence<double4x4>
        {
            [ReadOnly]
            public ValueSequence<double4x4, TSource> Source;

            [WriteOnly]
            public NativeArray<double4x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average();
            }
        }

        public static double4x4 RunAverage<TSource>(
            this in ValueSequence<double4x4, TSource> source
            )
            where TSource : struct, ISequence<double4x4>
        {
            var output = new NativeArray<double4x4>(1, Allocator.Persistent);
            new AverageJob_double4x4<TSource> { Source = source, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<TSource>(
            this in ValueSequence<double4x4, TSource> source,
            in NativeArray<double4x4> output
            )
            where TSource : struct, ISequence<double4x4>
        {
            return new AverageJob_double4x4<TSource> { Source = source, Output = output }.Schedule();
        }

        public static AverageJobHandle_double4x4 ScheduleAverage<TSource>(
            this in ValueSequence<double4x4, TSource> source
            )
            where TSource : struct, ISequence<double4x4>
        {
            var output = new NativeArray<double4x4>(1, Allocator.Persistent);
            var handle = new AverageJob_double4x4<TSource> { Source = source, Output = output }.Schedule();
            return new AverageJobHandle_double4x4(ref handle, ref output);
        }

        public static double4x4 Average<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double4x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4x4>
        {
            var srcList = source.ToNativeList(Allocator.Temp);
            if (srcList.Length == 0)
            {
                srcList.Dispose();
                throw Error.NoElements();
            }
            double4x4 sum = selector.Invoke(srcList[0]);
            for (var i = 1; i < srcList.Length; i++)
                sum += selector.Invoke(srcList[i]);
            var result = sum / srcList.Length;
            srcList.Dispose();
            return result;
        }

        [BurstCompile]
        public struct AverageJobSelector_double4x4<T, TSource, TSelector>
            : IJob
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4x4>
        {
            [ReadOnly]
            public ValueSequence<T, TSource> Source;
            public ValueFunc<T, double4x4>.Struct<TSelector> Selector;

            [WriteOnly]
            public NativeArray<double4x4> Output;

            public void Execute()
            {
                Output[0] = Source.Average(Selector);
            }
        }

        public static double4x4 RunAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double4x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4x4>
        {
            var output = new NativeArray<double4x4>(1, Allocator.Persistent);
            new AverageJobSelector_double4x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Run();
            var result = output[0];
            output.Dispose();
            return result;
        }

        public static JobHandle ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double4x4>.Struct<TSelector> selector,
            in NativeArray<double4x4> output
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4x4>
        {
            return new AverageJobSelector_double4x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
        }

        public static AverageJobHandle_double4x4 ScheduleAverage<T, TSource, TSelector>(
            this in ValueSequence<T, TSource> source,
            in ValueFunc<T, double4x4>.Struct<TSelector> selector
            )
            where T : struct
            where TSource : struct, ISequence<T>
            where TSelector : struct, IFunc<T, double4x4>
        {
            var output = new NativeArray<double4x4>(1, Allocator.Persistent);
            var handle = new AverageJobSelector_double4x4<T, TSource, TSelector> { Source = source, Selector = selector, Output = output }.Schedule();
            return new AverageJobHandle_double4x4(ref handle, ref output);
        }


    }
}
