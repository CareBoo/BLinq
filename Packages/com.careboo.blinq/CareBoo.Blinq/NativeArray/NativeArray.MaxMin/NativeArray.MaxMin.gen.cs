

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Packages/com.careboo.blinq/CareBoo.Blinq/ValueSequence/ValueSequence.Sum.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Unity.Collections;
using Unity.Jobs;
using CareBoo.Burst.Delegates;

namespace CareBoo.Blinq
{
    public static partial class Sequence
    {

        public static int Max(this in NativeArray<int> source)
        {
            if (source.Length == 0) throw Error.NoElements();

            var max = source[0];
            for (var i = 1; i < source.Length; i++)
            {
                var val = source[i];
                if (val > max)
                    max = val;
            }
            return max;
        }

        public struct ArrayMaxFunc_int
            : IFunc<NativeArray<int>, int>
        {
            public int Invoke(NativeArray<int> seq)
            {
                return seq.Max();
            }
        }

        public static ValueFunc<NativeArray<int>, int>.Struct<ArrayMaxFunc_int>
        MaxAsFunc(
            this in NativeArray<int> source
            )
        {
            return ValueFunc<NativeArray<int>, int>.New<ArrayMaxFunc_int>();
        }

        public static int RunMax(
            this in NativeArray<int> source
            )
        {
            var func = source.MaxAsFunc();
            return source.Run(func);
        }

        public static JobHandle<int> ScheduleMax(
            this in NativeArray<int> source
            )
        {
            var func = source.MaxAsFunc();
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMax(
            this in NativeArray<int> source,
            ref NativeArray<int> output
            )
        {
            var func = source.MaxAsFunc();
            return source.Schedule(func, ref output);
        }

        public static int Min(this in NativeArray<int> source)
        {
            if (source.Length == 0) throw Error.NoElements();

            var min = source[0];
            for (var i = 1; i < source.Length; i++)
            {
                var val = source[i];
                if (val < min)
                    min = val;
            }
            return min;
        }

        public struct ArrayMinFunc_int
            : IFunc<NativeArray<int>, int>
        {
            public int Invoke(NativeArray<int> seq)
            {
                return seq.Min();
            }
        }

        public static ValueFunc<NativeArray<int>, int>.Struct<ArrayMinFunc_int>
        MinAsFunc(
            this in NativeArray<int> source
            )
        {
            return ValueFunc<NativeArray<int>, int>.New<ArrayMinFunc_int>();
        }

        public static int RunMin(
            this in NativeArray<int> source
            )
        {
            var func = source.MinAsFunc();
            return source.Run(func);
        }

        public static JobHandle<int> ScheduleMin(
            this in NativeArray<int> source
            )
        {
            var func = source.MinAsFunc();
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMin(
            this in NativeArray<int> source,
            ref NativeArray<int> output
            )
        {
            var func = source.MinAsFunc();
            return source.Schedule(func, ref output);
        }

        public static int Max<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, int>
        {
            if (source.Length == 0) throw Error.NoElements();

            var max = selector.Invoke(source[0]);
            for (var i = 1; i < source.Length; i++)
            {
                var val = selector.Invoke(source[i]);
                if (val > max)
                    max = val;
            }
            return max;
        }

        public struct ArrayMaxFunc_int<T, TSelector>
            : IFunc<NativeArray<T>, int>
            where T : struct
            where TSelector : struct, IFunc<T, int>
        {
            public ValueFunc<T, int>.Struct<TSelector> Selector;

            public int Invoke(NativeArray<T> seq)
            {
                return seq.Max(Selector);
            }
        }

        public static ValueFunc<NativeArray<T>, int>.Struct<ArrayMaxFunc_int<T, TSelector>>
        MaxAsFunc<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, int>
        {
            var func = new ArrayMaxFunc_int<T, TSelector> { Selector = selector };
            return ValueFunc<NativeArray<T>, int>.New(func);
        }

        public static int RunMax<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, int>
        {
            var func = source.MaxAsFunc(selector);
            return source.Run(func);
        }

        public static JobHandle<int> ScheduleMax<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, int>
        {
            var func = source.MaxAsFunc(selector);
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMax<T, TSelector>(
            this in NativeArray<T> source,
            ref NativeArray<int> output,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, int>
        {
            var func = source.MaxAsFunc(selector);
            return source.Schedule(func, ref output);
        }

        public static int Min<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, int>
        {
            if (source.Length == 0) throw Error.NoElements();

            var min = selector.Invoke(source[0]);
            for (var i = 1; i < source.Length; i++)
            {
                var val = selector.Invoke(source[i]);
                if (val < min)
                    min = val;
            }
            return min;
        }

        public struct ArrayMinFunc_int<T, TSelector>
            : IFunc<NativeArray<T>, int>
            where T : struct
            where TSelector : struct, IFunc<T, int>
        {
            public ValueFunc<T, int>.Struct<TSelector> Selector;

            public int Invoke(NativeArray<T> seq)
            {
                return seq.Min(Selector);
            }
        }

        public static ValueFunc<NativeArray<T>, int>.Struct<ArrayMinFunc_int<T, TSelector>>
        MinAsFunc<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, int>
        {
            var func = new ArrayMinFunc_int<T, TSelector> { Selector = selector };
            return ValueFunc<NativeArray<T>, int>.New(func);
        }

        public static int RunMin<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, int>
        {
            var func = source.MinAsFunc(selector);
            return source.Run(func);
        }

        public static JobHandle<int> ScheduleMin<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, int>
        {
            var func = source.MinAsFunc(selector);
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMin<T, TSelector>(
            this in NativeArray<T> source,
            ref NativeArray<int> output,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, int>
        {
            var func = source.MinAsFunc(selector);
            return source.Schedule(func, ref output);
        }


        public static uint Max(this in NativeArray<uint> source)
        {
            if (source.Length == 0) throw Error.NoElements();

            var max = source[0];
            for (var i = 1; i < source.Length; i++)
            {
                var val = source[i];
                if (val > max)
                    max = val;
            }
            return max;
        }

        public struct ArrayMaxFunc_uint
            : IFunc<NativeArray<uint>, uint>
        {
            public uint Invoke(NativeArray<uint> seq)
            {
                return seq.Max();
            }
        }

        public static ValueFunc<NativeArray<uint>, uint>.Struct<ArrayMaxFunc_uint>
        MaxAsFunc(
            this in NativeArray<uint> source
            )
        {
            return ValueFunc<NativeArray<uint>, uint>.New<ArrayMaxFunc_uint>();
        }

        public static uint RunMax(
            this in NativeArray<uint> source
            )
        {
            var func = source.MaxAsFunc();
            return source.Run(func);
        }

        public static JobHandle<uint> ScheduleMax(
            this in NativeArray<uint> source
            )
        {
            var func = source.MaxAsFunc();
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMax(
            this in NativeArray<uint> source,
            ref NativeArray<uint> output
            )
        {
            var func = source.MaxAsFunc();
            return source.Schedule(func, ref output);
        }

        public static uint Min(this in NativeArray<uint> source)
        {
            if (source.Length == 0) throw Error.NoElements();

            var min = source[0];
            for (var i = 1; i < source.Length; i++)
            {
                var val = source[i];
                if (val < min)
                    min = val;
            }
            return min;
        }

        public struct ArrayMinFunc_uint
            : IFunc<NativeArray<uint>, uint>
        {
            public uint Invoke(NativeArray<uint> seq)
            {
                return seq.Min();
            }
        }

        public static ValueFunc<NativeArray<uint>, uint>.Struct<ArrayMinFunc_uint>
        MinAsFunc(
            this in NativeArray<uint> source
            )
        {
            return ValueFunc<NativeArray<uint>, uint>.New<ArrayMinFunc_uint>();
        }

        public static uint RunMin(
            this in NativeArray<uint> source
            )
        {
            var func = source.MinAsFunc();
            return source.Run(func);
        }

        public static JobHandle<uint> ScheduleMin(
            this in NativeArray<uint> source
            )
        {
            var func = source.MinAsFunc();
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMin(
            this in NativeArray<uint> source,
            ref NativeArray<uint> output
            )
        {
            var func = source.MinAsFunc();
            return source.Schedule(func, ref output);
        }

        public static uint Max<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, uint>
        {
            if (source.Length == 0) throw Error.NoElements();

            var max = selector.Invoke(source[0]);
            for (var i = 1; i < source.Length; i++)
            {
                var val = selector.Invoke(source[i]);
                if (val > max)
                    max = val;
            }
            return max;
        }

        public struct ArrayMaxFunc_uint<T, TSelector>
            : IFunc<NativeArray<T>, uint>
            where T : struct
            where TSelector : struct, IFunc<T, uint>
        {
            public ValueFunc<T, uint>.Struct<TSelector> Selector;

            public uint Invoke(NativeArray<T> seq)
            {
                return seq.Max(Selector);
            }
        }

        public static ValueFunc<NativeArray<T>, uint>.Struct<ArrayMaxFunc_uint<T, TSelector>>
        MaxAsFunc<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, uint>
        {
            var func = new ArrayMaxFunc_uint<T, TSelector> { Selector = selector };
            return ValueFunc<NativeArray<T>, uint>.New(func);
        }

        public static uint RunMax<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, uint>
        {
            var func = source.MaxAsFunc(selector);
            return source.Run(func);
        }

        public static JobHandle<uint> ScheduleMax<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, uint>
        {
            var func = source.MaxAsFunc(selector);
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMax<T, TSelector>(
            this in NativeArray<T> source,
            ref NativeArray<uint> output,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, uint>
        {
            var func = source.MaxAsFunc(selector);
            return source.Schedule(func, ref output);
        }

        public static uint Min<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, uint>
        {
            if (source.Length == 0) throw Error.NoElements();

            var min = selector.Invoke(source[0]);
            for (var i = 1; i < source.Length; i++)
            {
                var val = selector.Invoke(source[i]);
                if (val < min)
                    min = val;
            }
            return min;
        }

        public struct ArrayMinFunc_uint<T, TSelector>
            : IFunc<NativeArray<T>, uint>
            where T : struct
            where TSelector : struct, IFunc<T, uint>
        {
            public ValueFunc<T, uint>.Struct<TSelector> Selector;

            public uint Invoke(NativeArray<T> seq)
            {
                return seq.Min(Selector);
            }
        }

        public static ValueFunc<NativeArray<T>, uint>.Struct<ArrayMinFunc_uint<T, TSelector>>
        MinAsFunc<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, uint>
        {
            var func = new ArrayMinFunc_uint<T, TSelector> { Selector = selector };
            return ValueFunc<NativeArray<T>, uint>.New(func);
        }

        public static uint RunMin<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, uint>
        {
            var func = source.MinAsFunc(selector);
            return source.Run(func);
        }

        public static JobHandle<uint> ScheduleMin<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, uint>
        {
            var func = source.MinAsFunc(selector);
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMin<T, TSelector>(
            this in NativeArray<T> source,
            ref NativeArray<uint> output,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, uint>
        {
            var func = source.MinAsFunc(selector);
            return source.Schedule(func, ref output);
        }


        public static float Max(this in NativeArray<float> source)
        {
            if (source.Length == 0) throw Error.NoElements();

            var max = source[0];
            for (var i = 1; i < source.Length; i++)
            {
                var val = source[i];
                if (val > max)
                    max = val;
            }
            return max;
        }

        public struct ArrayMaxFunc_float
            : IFunc<NativeArray<float>, float>
        {
            public float Invoke(NativeArray<float> seq)
            {
                return seq.Max();
            }
        }

        public static ValueFunc<NativeArray<float>, float>.Struct<ArrayMaxFunc_float>
        MaxAsFunc(
            this in NativeArray<float> source
            )
        {
            return ValueFunc<NativeArray<float>, float>.New<ArrayMaxFunc_float>();
        }

        public static float RunMax(
            this in NativeArray<float> source
            )
        {
            var func = source.MaxAsFunc();
            return source.Run(func);
        }

        public static JobHandle<float> ScheduleMax(
            this in NativeArray<float> source
            )
        {
            var func = source.MaxAsFunc();
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMax(
            this in NativeArray<float> source,
            ref NativeArray<float> output
            )
        {
            var func = source.MaxAsFunc();
            return source.Schedule(func, ref output);
        }

        public static float Min(this in NativeArray<float> source)
        {
            if (source.Length == 0) throw Error.NoElements();

            var min = source[0];
            for (var i = 1; i < source.Length; i++)
            {
                var val = source[i];
                if (val < min)
                    min = val;
            }
            return min;
        }

        public struct ArrayMinFunc_float
            : IFunc<NativeArray<float>, float>
        {
            public float Invoke(NativeArray<float> seq)
            {
                return seq.Min();
            }
        }

        public static ValueFunc<NativeArray<float>, float>.Struct<ArrayMinFunc_float>
        MinAsFunc(
            this in NativeArray<float> source
            )
        {
            return ValueFunc<NativeArray<float>, float>.New<ArrayMinFunc_float>();
        }

        public static float RunMin(
            this in NativeArray<float> source
            )
        {
            var func = source.MinAsFunc();
            return source.Run(func);
        }

        public static JobHandle<float> ScheduleMin(
            this in NativeArray<float> source
            )
        {
            var func = source.MinAsFunc();
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMin(
            this in NativeArray<float> source,
            ref NativeArray<float> output
            )
        {
            var func = source.MinAsFunc();
            return source.Schedule(func, ref output);
        }

        public static float Max<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, float>
        {
            if (source.Length == 0) throw Error.NoElements();

            var max = selector.Invoke(source[0]);
            for (var i = 1; i < source.Length; i++)
            {
                var val = selector.Invoke(source[i]);
                if (val > max)
                    max = val;
            }
            return max;
        }

        public struct ArrayMaxFunc_float<T, TSelector>
            : IFunc<NativeArray<T>, float>
            where T : struct
            where TSelector : struct, IFunc<T, float>
        {
            public ValueFunc<T, float>.Struct<TSelector> Selector;

            public float Invoke(NativeArray<T> seq)
            {
                return seq.Max(Selector);
            }
        }

        public static ValueFunc<NativeArray<T>, float>.Struct<ArrayMaxFunc_float<T, TSelector>>
        MaxAsFunc<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, float>
        {
            var func = new ArrayMaxFunc_float<T, TSelector> { Selector = selector };
            return ValueFunc<NativeArray<T>, float>.New(func);
        }

        public static float RunMax<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, float>
        {
            var func = source.MaxAsFunc(selector);
            return source.Run(func);
        }

        public static JobHandle<float> ScheduleMax<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, float>
        {
            var func = source.MaxAsFunc(selector);
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMax<T, TSelector>(
            this in NativeArray<T> source,
            ref NativeArray<float> output,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, float>
        {
            var func = source.MaxAsFunc(selector);
            return source.Schedule(func, ref output);
        }

        public static float Min<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, float>
        {
            if (source.Length == 0) throw Error.NoElements();

            var min = selector.Invoke(source[0]);
            for (var i = 1; i < source.Length; i++)
            {
                var val = selector.Invoke(source[i]);
                if (val < min)
                    min = val;
            }
            return min;
        }

        public struct ArrayMinFunc_float<T, TSelector>
            : IFunc<NativeArray<T>, float>
            where T : struct
            where TSelector : struct, IFunc<T, float>
        {
            public ValueFunc<T, float>.Struct<TSelector> Selector;

            public float Invoke(NativeArray<T> seq)
            {
                return seq.Min(Selector);
            }
        }

        public static ValueFunc<NativeArray<T>, float>.Struct<ArrayMinFunc_float<T, TSelector>>
        MinAsFunc<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, float>
        {
            var func = new ArrayMinFunc_float<T, TSelector> { Selector = selector };
            return ValueFunc<NativeArray<T>, float>.New(func);
        }

        public static float RunMin<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, float>
        {
            var func = source.MinAsFunc(selector);
            return source.Run(func);
        }

        public static JobHandle<float> ScheduleMin<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, float>
        {
            var func = source.MinAsFunc(selector);
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMin<T, TSelector>(
            this in NativeArray<T> source,
            ref NativeArray<float> output,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, float>
        {
            var func = source.MinAsFunc(selector);
            return source.Schedule(func, ref output);
        }


        public static double Max(this in NativeArray<double> source)
        {
            if (source.Length == 0) throw Error.NoElements();

            var max = source[0];
            for (var i = 1; i < source.Length; i++)
            {
                var val = source[i];
                if (val > max)
                    max = val;
            }
            return max;
        }

        public struct ArrayMaxFunc_double
            : IFunc<NativeArray<double>, double>
        {
            public double Invoke(NativeArray<double> seq)
            {
                return seq.Max();
            }
        }

        public static ValueFunc<NativeArray<double>, double>.Struct<ArrayMaxFunc_double>
        MaxAsFunc(
            this in NativeArray<double> source
            )
        {
            return ValueFunc<NativeArray<double>, double>.New<ArrayMaxFunc_double>();
        }

        public static double RunMax(
            this in NativeArray<double> source
            )
        {
            var func = source.MaxAsFunc();
            return source.Run(func);
        }

        public static JobHandle<double> ScheduleMax(
            this in NativeArray<double> source
            )
        {
            var func = source.MaxAsFunc();
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMax(
            this in NativeArray<double> source,
            ref NativeArray<double> output
            )
        {
            var func = source.MaxAsFunc();
            return source.Schedule(func, ref output);
        }

        public static double Min(this in NativeArray<double> source)
        {
            if (source.Length == 0) throw Error.NoElements();

            var min = source[0];
            for (var i = 1; i < source.Length; i++)
            {
                var val = source[i];
                if (val < min)
                    min = val;
            }
            return min;
        }

        public struct ArrayMinFunc_double
            : IFunc<NativeArray<double>, double>
        {
            public double Invoke(NativeArray<double> seq)
            {
                return seq.Min();
            }
        }

        public static ValueFunc<NativeArray<double>, double>.Struct<ArrayMinFunc_double>
        MinAsFunc(
            this in NativeArray<double> source
            )
        {
            return ValueFunc<NativeArray<double>, double>.New<ArrayMinFunc_double>();
        }

        public static double RunMin(
            this in NativeArray<double> source
            )
        {
            var func = source.MinAsFunc();
            return source.Run(func);
        }

        public static JobHandle<double> ScheduleMin(
            this in NativeArray<double> source
            )
        {
            var func = source.MinAsFunc();
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMin(
            this in NativeArray<double> source,
            ref NativeArray<double> output
            )
        {
            var func = source.MinAsFunc();
            return source.Schedule(func, ref output);
        }

        public static double Max<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, double>
        {
            if (source.Length == 0) throw Error.NoElements();

            var max = selector.Invoke(source[0]);
            for (var i = 1; i < source.Length; i++)
            {
                var val = selector.Invoke(source[i]);
                if (val > max)
                    max = val;
            }
            return max;
        }

        public struct ArrayMaxFunc_double<T, TSelector>
            : IFunc<NativeArray<T>, double>
            where T : struct
            where TSelector : struct, IFunc<T, double>
        {
            public ValueFunc<T, double>.Struct<TSelector> Selector;

            public double Invoke(NativeArray<T> seq)
            {
                return seq.Max(Selector);
            }
        }

        public static ValueFunc<NativeArray<T>, double>.Struct<ArrayMaxFunc_double<T, TSelector>>
        MaxAsFunc<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, double>
        {
            var func = new ArrayMaxFunc_double<T, TSelector> { Selector = selector };
            return ValueFunc<NativeArray<T>, double>.New(func);
        }

        public static double RunMax<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, double>
        {
            var func = source.MaxAsFunc(selector);
            return source.Run(func);
        }

        public static JobHandle<double> ScheduleMax<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, double>
        {
            var func = source.MaxAsFunc(selector);
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMax<T, TSelector>(
            this in NativeArray<T> source,
            ref NativeArray<double> output,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, double>
        {
            var func = source.MaxAsFunc(selector);
            return source.Schedule(func, ref output);
        }

        public static double Min<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, double>
        {
            if (source.Length == 0) throw Error.NoElements();

            var min = selector.Invoke(source[0]);
            for (var i = 1; i < source.Length; i++)
            {
                var val = selector.Invoke(source[i]);
                if (val < min)
                    min = val;
            }
            return min;
        }

        public struct ArrayMinFunc_double<T, TSelector>
            : IFunc<NativeArray<T>, double>
            where T : struct
            where TSelector : struct, IFunc<T, double>
        {
            public ValueFunc<T, double>.Struct<TSelector> Selector;

            public double Invoke(NativeArray<T> seq)
            {
                return seq.Min(Selector);
            }
        }

        public static ValueFunc<NativeArray<T>, double>.Struct<ArrayMinFunc_double<T, TSelector>>
        MinAsFunc<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, double>
        {
            var func = new ArrayMinFunc_double<T, TSelector> { Selector = selector };
            return ValueFunc<NativeArray<T>, double>.New(func);
        }

        public static double RunMin<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, double>
        {
            var func = source.MinAsFunc(selector);
            return source.Run(func);
        }

        public static JobHandle<double> ScheduleMin<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, double>
        {
            var func = source.MinAsFunc(selector);
            return source.Schedule(func);
        }

        public static JobHandle ScheduleMin<T, TSelector>(
            this in NativeArray<T> source,
            ref NativeArray<double> output,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, double>
        {
            var func = source.MinAsFunc(selector);
            return source.Schedule(func, ref output);
        }


    }
}
