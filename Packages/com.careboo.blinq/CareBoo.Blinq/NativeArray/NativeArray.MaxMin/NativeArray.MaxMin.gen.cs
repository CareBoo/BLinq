//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     TextTransform Packages/com.careboo.blinq/CareBoo.Blinq/ValueSequence/ValueSequence.Sum.tt
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Unity.Collections;
using CareBoo.Burst.Delegates;

namespace CareBoo.Blinq
{
    public static partial class Sequence
    {
        public static int Max(this in NativeArray<int> source)
        {
            if (source.Length == 0) throw Error.NoElements();

            var max = source[0];
            for (var i = 1; i < source.Length; i++)
            {
                var val = source[i];
                if (val > max)
                    max = val;
            }
            return max;
        }

        public static int Min(this in NativeArray<int> source)
        {
            if (source.Length == 0) throw Error.NoElements();

            var min = source[0];
            for (var i = 1; i < source.Length; i++)
            {
                var val = source[i];
                if (val < min)
                    min = val;
            }
            return min;
        }

        public static int Max<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, int>
        {
            if (source.Length == 0) throw Error.NoElements();

            var max = selector.Invoke(source[0]);
            for (var i = 1; i < source.Length; i++)
            {
                var val = selector.Invoke(source[i]);
                if (val > max)
                    max = val;
            }
            return max;
        }

        public static int Min<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, int>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, int>
        {
            if (source.Length == 0) throw Error.NoElements();

            var min = selector.Invoke(source[0]);
            for (var i = 1; i < source.Length; i++)
            {
                var val = selector.Invoke(source[i]);
                if (val < min)
                    min = val;
            }
            return min;
        }

        public static uint Max(this in NativeArray<uint> source)
        {
            if (source.Length == 0) throw Error.NoElements();

            var max = source[0];
            for (var i = 1; i < source.Length; i++)
            {
                var val = source[i];
                if (val > max)
                    max = val;
            }
            return max;
        }

        public static uint Min(this in NativeArray<uint> source)
        {
            if (source.Length == 0) throw Error.NoElements();

            var min = source[0];
            for (var i = 1; i < source.Length; i++)
            {
                var val = source[i];
                if (val < min)
                    min = val;
            }
            return min;
        }

        public static uint Max<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, uint>
        {
            if (source.Length == 0) throw Error.NoElements();

            var max = selector.Invoke(source[0]);
            for (var i = 1; i < source.Length; i++)
            {
                var val = selector.Invoke(source[i]);
                if (val > max)
                    max = val;
            }
            return max;
        }

        public static uint Min<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, uint>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, uint>
        {
            if (source.Length == 0) throw Error.NoElements();

            var min = selector.Invoke(source[0]);
            for (var i = 1; i < source.Length; i++)
            {
                var val = selector.Invoke(source[i]);
                if (val < min)
                    min = val;
            }
            return min;
        }

        public static float Max(this in NativeArray<float> source)
        {
            if (source.Length == 0) throw Error.NoElements();

            var max = source[0];
            for (var i = 1; i < source.Length; i++)
            {
                var val = source[i];
                if (val > max)
                    max = val;
            }
            return max;
        }

        public static float Min(this in NativeArray<float> source)
        {
            if (source.Length == 0) throw Error.NoElements();

            var min = source[0];
            for (var i = 1; i < source.Length; i++)
            {
                var val = source[i];
                if (val < min)
                    min = val;
            }
            return min;
        }

        public static float Max<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, float>
        {
            if (source.Length == 0) throw Error.NoElements();

            var max = selector.Invoke(source[0]);
            for (var i = 1; i < source.Length; i++)
            {
                var val = selector.Invoke(source[i]);
                if (val > max)
                    max = val;
            }
            return max;
        }

        public static float Min<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, float>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, float>
        {
            if (source.Length == 0) throw Error.NoElements();

            var min = selector.Invoke(source[0]);
            for (var i = 1; i < source.Length; i++)
            {
                var val = selector.Invoke(source[i]);
                if (val < min)
                    min = val;
            }
            return min;
        }

        public static double Max(this in NativeArray<double> source)
        {
            if (source.Length == 0) throw Error.NoElements();

            var max = source[0];
            for (var i = 1; i < source.Length; i++)
            {
                var val = source[i];
                if (val > max)
                    max = val;
            }
            return max;
        }

        public static double Min(this in NativeArray<double> source)
        {
            if (source.Length == 0) throw Error.NoElements();

            var min = source[0];
            for (var i = 1; i < source.Length; i++)
            {
                var val = source[i];
                if (val < min)
                    min = val;
            }
            return min;
        }

        public static double Max<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, double>
        {
            if (source.Length == 0) throw Error.NoElements();

            var max = selector.Invoke(source[0]);
            for (var i = 1; i < source.Length; i++)
            {
                var val = selector.Invoke(source[i]);
                if (val > max)
                    max = val;
            }
            return max;
        }

        public static double Min<T, TSelector>(
            this in NativeArray<T> source,
            ValueFunc<T, double>.Struct<TSelector> selector
            )
            where T : struct
            where TSelector : struct, IFunc<T, double>
        {
            if (source.Length == 0) throw Error.NoElements();

            var min = selector.Invoke(source[0]);
            for (var i = 1; i < source.Length; i++)
            {
                var val = selector.Invoke(source[i]);
                if (val < min)
                    min = val;
            }
            return min;
        }

    }
}
